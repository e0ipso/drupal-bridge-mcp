/**
 * Integration Tests for Simplified MCP Server
 *
 * Tests the complete MCP server flow with direct token pass-through to Drupal
 * without complex session management.
 */

import {
  describe,
  it,
  expect,
  beforeEach,
  afterEach,
  jest,
} from '@jest/globals';
import { Server } from '@modelcontextprotocol/sdk/server/index';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types';
import { SimplifiedMCPServer } from '../../src/mcp/server';
import { JsonRpcClient } from '../../src/drupal/json-rpc-client';
import { TokenExtractor } from '../../src/mcp/token-extractor';

// Mock the Drupal client
jest.mock('../../src/drupal/json-rpc-client');
const MockedJsonRpcClient = JsonRpcClient as jest.MockedClass<
  typeof JsonRpcClient
>;

// Mock the logger
jest.mock('../../src/utils/logger', () => ({
  logger: {
    info: jest.fn(),
    debug: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
  },
}));

describe('Simplified MCP Server Integration', () => {
  let mcpServer: SimplifiedMCPServer;
  let mockDrupalClient: jest.Mocked<JsonRpcClient>;
  let server: Server;

  const VALID_TOKEN = 'valid-test-token-12345678';
  const INVALID_TOKEN = 'invalid';
  const EXPIRED_TOKEN = 'expired-token-12345678';

  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();

    // Create mock Drupal client instance
    mockDrupalClient = {
      searchContent: jest.fn(),
      getTutorial: jest.fn(),
      discoverMethods: jest.fn(),
      healthCheck: jest.fn(),
      call: jest.fn(),
    } as any;

    // Mock the JsonRpcClient constructor
    MockedJsonRpcClient.mockImplementation(() => mockDrupalClient);

    // Create MCP server instance
    mcpServer = new SimplifiedMCPServer({
      baseUrl: 'http://localhost:8080/jsonrpc',
    });
    server = mcpServer.getServer();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Server Initialization', () => {
    it('should initialize with Drupal client', () => {
      expect(MockedJsonRpcClient).toHaveBeenCalledWith({
        baseUrl: 'http://localhost:8080/jsonrpc',
      });
    });

    it('should return valid Server instance', () => {
      expect(server).toBeInstanceOf(Server);
    });
  });

  describe('Tool Discovery', () => {
    it('should list all available tools', async () => {
      const toolHandler = server['requestHandlers'].get('tools/list');
      expect(toolHandler).toBeDefined();

      const response = await toolHandler!({
        method: 'tools/list',
        params: {},
      } as any);

      expect(response.tools).toHaveLength(4);
      expect(response.tools.map((t: any) => t.name)).toEqual([
        'search_content',
        'get_tutorial',
        'discover_methods',
        'health_check',
      ]);
    });

    it('should provide correct tool schemas', async () => {
      const toolHandler = server['requestHandlers'].get('tools/list');
      const response = await toolHandler!({
        method: 'tools/list',
        params: {},
      } as any);

      const searchTool = response.tools.find(
        (t: any) => t.name === 'search_content'
      );
      expect(searchTool.inputSchema.required).toEqual(['query']);
      expect(searchTool.inputSchema.properties.query.type).toBe('string');

      const getTutorialTool = response.tools.find(
        (t: any) => t.name === 'get_tutorial'
      );
      expect(getTutorialTool.inputSchema.required).toEqual(['id']);
      expect(getTutorialTool.inputSchema.properties.id.type).toBe('string');
    });
  });

  describe('Token Extraction and Validation', () => {
    const createMockRequest = (token?: string) => ({
      method: 'tools/call',
      params: {
        name: 'search_content',
        arguments: { query: 'test' },
      },
      meta: {
        headers: token ? { authorization: `Bearer ${token}` } : {},
      },
    });

    it('should extract valid token from Authorization header', async () => {
      const request = createMockRequest(VALID_TOKEN);

      mockDrupalClient.searchContent.mockResolvedValue({
        results: [],
        total: 0,
        limit: 20,
        offset: 0,
        query: 'test',
        took: 5,
      });

      const callHandler = server['requestHandlers'].get('tools/call');
      await callHandler!(request as any);

      expect(mockDrupalClient.searchContent).toHaveBeenCalledWith(
        expect.objectContaining({ query: 'test' }),
        VALID_TOKEN
      );
    });

    it('should reject request with missing token', async () => {
      const request = createMockRequest();
      const callHandler = server['requestHandlers'].get('tools/call');

      await expect(callHandler!(request as any)).rejects.toThrow(McpError);
      await expect(callHandler!(request as any)).rejects.toMatchObject({
        code: ErrorCode.InvalidRequest,
        message: expect.stringContaining('authentication token'),
      });
    });

    it('should reject request with invalid token format', async () => {
      const request = createMockRequest(INVALID_TOKEN);
      const callHandler = server['requestHandlers'].get('tools/call');

      await expect(callHandler!(request as any)).rejects.toThrow(McpError);
      await expect(callHandler!(request as any)).rejects.toMatchObject({
        code: ErrorCode.InvalidRequest,
        message: expect.stringContaining('too short'),
      });
    });

    it('should extract token from request parameters as fallback', async () => {
      const request = {
        method: 'tools/call',
        params: {
          name: 'search_content',
          arguments: {
            query: 'test',
            access_token: VALID_TOKEN,
          },
        },
        meta: { headers: {} },
      };

      mockDrupalClient.searchContent.mockResolvedValue({
        results: [],
        total: 0,
        limit: 20,
        offset: 0,
        query: 'test',
        took: 5,
      });

      const callHandler = server['requestHandlers'].get('tools/call');
      await callHandler!(request as any);

      expect(mockDrupalClient.searchContent).toHaveBeenCalledWith(
        expect.objectContaining({ query: 'test' }),
        VALID_TOKEN
      );
    });
  });

  describe('Search Content Tool', () => {
    const createSearchRequest = (args: any, token = VALID_TOKEN) => ({
      method: 'tools/call',
      params: {
        name: 'search_content',
        arguments: args,
      },
      meta: {
        headers: { authorization: `Bearer ${token}` },
      },
    });

    it('should handle successful search', async () => {
      const mockResults = {
        results: [
          {
            id: 'tutorial-1',
            title: 'Getting Started with Drupal',
            summary: 'Learn the basics of Drupal development',
            content_type: 'tutorial',
            tags: ['drupal', 'beginner'],
            drupal_version: '10',
            difficulty_level: 'beginner',
            created: '2023-01-01T00:00:00Z',
            updated: '2023-06-01T00:00:00Z',
            access_level: 'free' as const,
            url: 'https://drupalize.me/tutorial/getting-started',
            author: { name: 'John Doe' },
          },
        ],
        total: 1,
        limit: 20,
        offset: 0,
        query: 'drupal basics',
        took: 15,
      };

      mockDrupalClient.searchContent.mockResolvedValue(mockResults);

      const request = createSearchRequest({ query: 'drupal basics' });
      const callHandler = server['requestHandlers'].get('tools/call');
      const response = await callHandler!(request as any);

      expect(mockDrupalClient.searchContent).toHaveBeenCalledWith(
        {
          query: 'drupal basics',
          content_type: 'all',
          tags: [],
          limit: 20,
          offset: 0,
          sort: 'relevance',
          access_level: 'all',
          drupal_version: undefined,
        },
        VALID_TOKEN
      );

      expect(response.content).toHaveLength(1);
      expect(response.content[0].text).toContain('Getting Started with Drupal');
      expect(response.content[0].text).toContain('Found 1 results in 15ms');
    });

    it('should handle search with filters', async () => {
      mockDrupalClient.searchContent.mockResolvedValue({
        results: [],
        total: 0,
        limit: 10,
        offset: 0,
        query: 'advanced',
        took: 8,
      });

      const request = createSearchRequest({
        query: 'advanced',
        content_type: 'tutorial',
        drupal_version: '10',
        tags: ['advanced', 'api'],
        limit: 10,
        sort: 'date',
      });

      const callHandler = server['requestHandlers'].get('tools/call');
      await callHandler!(request as any);

      expect(mockDrupalClient.searchContent).toHaveBeenCalledWith(
        {
          query: 'advanced',
          content_type: 'tutorial',
          drupal_version: '10',
          tags: ['advanced', 'api'],
          limit: 10,
          offset: 0,
          sort: 'date',
          access_level: 'all',
        },
        VALID_TOKEN
      );
    });

    it('should reject search without query parameter', async () => {
      const request = createSearchRequest({});
      const callHandler = server['requestHandlers'].get('tools/call');

      await expect(callHandler!(request as any)).rejects.toThrow(McpError);
      await expect(callHandler!(request as any)).rejects.toMatchObject({
        code: ErrorCode.InvalidParams,
        message: expect.stringContaining('Missing required parameter: query'),
      });
    });

    it('should handle empty search results', async () => {
      mockDrupalClient.searchContent.mockResolvedValue({
        results: [],
        total: 0,
        limit: 20,
        offset: 0,
        query: 'nonexistent',
        took: 3,
      });

      const request = createSearchRequest({ query: 'nonexistent' });
      const callHandler = server['requestHandlers'].get('tools/call');
      const response = await callHandler!(request as any);

      expect(response.content[0].text).toContain(
        'No tutorials found matching your query'
      );
    });
  });

  describe('Get Tutorial Tool', () => {
    const createTutorialRequest = (args: any, token = VALID_TOKEN) => ({
      method: 'tools/call',
      params: {
        name: 'get_tutorial',
        arguments: args,
      },
      meta: {
        headers: { authorization: `Bearer ${token}` },
      },
    });

    it('should retrieve tutorial successfully', async () => {
      const mockTutorial = {
        id: 'tutorial-1',
        title: 'Advanced Drupal Development',
        summary: 'Deep dive into Drupal development',
        content: '# Advanced Drupal Development\n\nThis tutorial covers...',
        content_type: 'tutorial',
        tags: ['drupal', 'advanced'],
        drupal_version: '10',
        difficulty_level: 'advanced',
        created: '2023-01-01T00:00:00Z',
        updated: '2023-06-01T00:00:00Z',
        access_level: 'subscriber' as const,
        url: 'https://drupalize.me/tutorial/advanced',
        author: {
          name: 'Jane Smith',
          bio: 'Senior Drupal Developer',
        },
      };

      mockDrupalClient.getTutorial.mockResolvedValue(mockTutorial);

      const request = createTutorialRequest({ id: 'tutorial-1' });
      const callHandler = server['requestHandlers'].get('tools/call');
      const response = await callHandler!(request as any);

      expect(mockDrupalClient.getTutorial).toHaveBeenCalledWith(
        {
          id: 'tutorial-1',
          include_content: true,
          format: 'markdown',
        },
        VALID_TOKEN
      );

      expect(response.content[0].text).toContain('Advanced Drupal Development');
      expect(response.content[0].text).toContain('This tutorial covers...');
      expect(response.content[0].text).toContain('Jane Smith');
    });

    it('should handle tutorial request without content', async () => {
      const mockTutorial = {
        id: 'tutorial-2',
        title: 'Basic Tutorial',
        content_type: 'tutorial',
        tags: [],
        created: '2023-01-01T00:00:00Z',
        updated: '2023-01-01T00:00:00Z',
        access_level: 'free' as const,
      };

      mockDrupalClient.getTutorial.mockResolvedValue(mockTutorial);

      const request = createTutorialRequest({
        id: 'tutorial-2',
        include_content: false,
      });

      const callHandler = server['requestHandlers'].get('tools/call');
      const response = await callHandler!(request as any);

      expect(response.content[0].text).toContain(
        'Content not included in response'
      );
    });

    it('should reject request without tutorial ID', async () => {
      const request = createTutorialRequest({});
      const callHandler = server['requestHandlers'].get('tools/call');

      await expect(callHandler!(request as any)).rejects.toThrow(McpError);
      await expect(callHandler!(request as any)).rejects.toMatchObject({
        code: ErrorCode.InvalidParams,
        message: expect.stringContaining('Missing required parameter: id'),
      });
    });
  });

  describe('Health Check Tool', () => {
    const createHealthRequest = (token = VALID_TOKEN) => ({
      method: 'tools/call',
      params: {
        name: 'health_check',
        arguments: {},
      },
      meta: {
        headers: { authorization: `Bearer ${token}` },
      },
    });

    it('should perform health check successfully', async () => {
      const mockHealth = {
        status: 'healthy',
        timestamp: Date.now(),
      };

      mockDrupalClient.healthCheck.mockResolvedValue(mockHealth);

      const request = createHealthRequest();
      const callHandler = server['requestHandlers'].get('tools/call');
      const response = await callHandler!(request as any);

      expect(mockDrupalClient.healthCheck).toHaveBeenCalledWith(VALID_TOKEN);
      expect(response.content[0].text).toContain('Status: healthy');
      expect(response.content[0].text).toContain('Connection: OK');
    });
  });

  describe('Method Discovery Tool', () => {
    const createDiscoveryRequest = (token = VALID_TOKEN) => ({
      method: 'tools/call',
      params: {
        name: 'discover_methods',
        arguments: {},
      },
      meta: {
        headers: { authorization: `Bearer ${token}` },
      },
    });

    it('should discover available methods', async () => {
      const mockMethods = [
        'content.search',
        'content.get_tutorial',
        'system.health',
        'system.listMethods',
      ];

      mockDrupalClient.discoverMethods.mockResolvedValue(mockMethods);

      const request = createDiscoveryRequest();
      const callHandler = server['requestHandlers'].get('tools/call');
      const response = await callHandler!(request as any);

      expect(mockDrupalClient.discoverMethods).toHaveBeenCalledWith(
        VALID_TOKEN
      );
      expect(response.content[0].text).toContain(
        'Available Drupal JSON-RPC Methods'
      );
      expect(response.content[0].text).toContain('content.search');
      expect(response.content[0].text).toContain('system.health');
    });
  });

  describe('Error Handling', () => {
    it('should handle unknown tool gracefully', async () => {
      const request = {
        method: 'tools/call',
        params: {
          name: 'unknown_tool',
          arguments: {},
        },
        meta: {
          headers: { authorization: `Bearer ${VALID_TOKEN}` },
        },
      };

      const callHandler = server['requestHandlers'].get('tools/call');

      await expect(callHandler!(request as any)).rejects.toThrow(McpError);
      await expect(callHandler!(request as any)).rejects.toMatchObject({
        code: ErrorCode.MethodNotFound,
        message: expect.stringContaining('Unknown tool: unknown_tool'),
      });
    });

    it('should handle Drupal authentication errors', async () => {
      mockDrupalClient.searchContent.mockRejectedValue({
        isDrupalError: true,
        code: 401,
        message: 'Unauthorized',
      });

      const request = {
        method: 'tools/call',
        params: {
          name: 'search_content',
          arguments: { query: 'test' },
        },
        meta: {
          headers: { authorization: `Bearer ${EXPIRED_TOKEN}` },
        },
      };

      const callHandler = server['requestHandlers'].get('tools/call');

      await expect(callHandler!(request as any)).rejects.toThrow(McpError);
      // The exact error handling would depend on DrupalErrorUtils implementation
    });

    it('should handle network errors gracefully', async () => {
      mockDrupalClient.searchContent.mockRejectedValue({
        code: 'ECONNREFUSED',
        message: 'Connection refused',
      });

      const request = {
        method: 'tools/call',
        params: {
          name: 'search_content',
          arguments: { query: 'test' },
        },
        meta: {
          headers: { authorization: `Bearer ${VALID_TOKEN}` },
        },
      };

      const callHandler = server['requestHandlers'].get('tools/call');

      await expect(callHandler!(request as any)).rejects.toThrow(McpError);
      await expect(callHandler!(request as any)).rejects.toMatchObject({
        code: ErrorCode.InternalError,
      });
    });
  });

  describe('Direct Token Pass-through', () => {
    it('should pass token directly to all Drupal client methods', async () => {
      const testToken = 'test-token-123456789';

      // Test search_content
      mockDrupalClient.searchContent.mockResolvedValue({
        results: [],
        total: 0,
        limit: 20,
        offset: 0,
        query: 'test',
        took: 5,
      });

      const searchRequest = {
        method: 'tools/call',
        params: { name: 'search_content', arguments: { query: 'test' } },
        meta: { headers: { authorization: `Bearer ${testToken}` } },
      };

      const callHandler = server['requestHandlers'].get('tools/call');
      await callHandler!(searchRequest as any);

      expect(mockDrupalClient.searchContent).toHaveBeenCalledWith(
        expect.any(Object),
        testToken
      );

      // Test get_tutorial
      mockDrupalClient.getTutorial.mockResolvedValue({
        id: 'test',
        title: 'Test',
        content_type: 'tutorial',
        tags: [],
        created: '2023-01-01T00:00:00Z',
        updated: '2023-01-01T00:00:00Z',
        access_level: 'free' as const,
      });

      const tutorialRequest = {
        method: 'tools/call',
        params: { name: 'get_tutorial', arguments: { id: 'test' } },
        meta: { headers: { authorization: `Bearer ${testToken}` } },
      };

      await callHandler!(tutorialRequest as any);

      expect(mockDrupalClient.getTutorial).toHaveBeenCalledWith(
        expect.any(Object),
        testToken
      );
    });

    it('should not store or cache tokens', async () => {
      // This test verifies that the server is truly stateless
      const token1 = 'token-1-123456789';
      const token2 = 'token-2-987654321';

      mockDrupalClient.searchContent.mockResolvedValue({
        results: [],
        total: 0,
        limit: 20,
        offset: 0,
        query: 'test',
        took: 5,
      });

      // First request with token1
      const request1 = {
        method: 'tools/call',
        params: { name: 'search_content', arguments: { query: 'test1' } },
        meta: { headers: { authorization: `Bearer ${token1}` } },
      };

      // Second request with token2
      const request2 = {
        method: 'tools/call',
        params: { name: 'search_content', arguments: { query: 'test2' } },
        meta: { headers: { authorization: `Bearer ${token2}` } },
      };

      const callHandler = server['requestHandlers'].get('tools/call');

      await callHandler!(request1 as any);
      await callHandler!(request2 as any);

      expect(mockDrupalClient.searchContent).toHaveBeenNthCalledWith(
        1,
        expect.objectContaining({ query: 'test1' }),
        token1
      );

      expect(mockDrupalClient.searchContent).toHaveBeenNthCalledWith(
        2,
        expect.objectContaining({ query: 'test2' }),
        token2
      );

      // Verify each call used the correct token
      expect(mockDrupalClient.searchContent).toHaveBeenCalledTimes(2);
    });
  });
});
