/**
 * Security middleware for the MCP server
 * 
 * Implements security headers, HTTPS enforcement, rate limiting,
 * and other security best practices for production deployment.
 */

import type { Request, Response, NextFunction } from 'express';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import cors from 'cors';
import { config } from '@/config/index.js';
import { logger } from '@/utils/logger.js';

/**
 * HTTPS enforcement middleware
 * Redirects HTTP requests to HTTPS in production
 */
export function httpsEnforcement(req: Request, res: Response, next: NextFunction): void {
  if (config.security.httpsOnly) {
    // Check if request is secure or via proxy (Railway, Heroku, etc.)
    const isSecure = req.secure || 
                    req.get('X-Forwarded-Proto') === 'https' ||
                    req.get('X-Forwarded-Scheme') === 'https' ||
                    req.connection.encrypted;

    if (!isSecure) {
      logger.warn('Redirecting insecure request to HTTPS', {
        originalUrl: req.originalUrl,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
      });

      const httpsUrl = `https://${req.get('Host')}${req.originalUrl}`;
      return res.redirect(301, httpsUrl);
    }
  }
  
  next();
}

/**
 * Security headers middleware using Helmet
 * Configures comprehensive security headers
 */
export function securityHeaders() {
  if (!config.security.headers.enabled) {
    return (req: Request, res: Response, next: NextFunction) => next();
  }

  return helmet({
    // HTTP Strict Transport Security
    hsts: config.security.headers.hsts ? {
      maxAge: 31536000, // 1 year
      includeSubDomains: true,
      preload: true,
    } : false,

    // Content Security Policy
    contentSecurityPolicy: config.security.headers.contentSecurityPolicy ? {
      directives: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'", "'unsafe-inline'"], // Allow inline scripts for health checks
        styleSrc: ["'self'", "'unsafe-inline'"],
        imgSrc: ["'self'", "data:", "https:"],
        connectSrc: ["'self'"],
        fontSrc: ["'self'", "https:", "data:"],
        objectSrc: ["'none'"],
        mediaSrc: ["'self'"],
        frameSrc: ["'none'"],
        workerSrc: ["'self'"],
        manifestSrc: ["'self'"],
        upgradeInsecureRequests: config.security.httpsOnly ? [] : null,
      },
    } : false,

    // X-Content-Type-Options
    noSniff: config.security.headers.noSniff,

    // X-XSS-Protection (legacy header but still useful)
    xssFilter: config.security.headers.xssProtection,

    // Referrer Policy
    referrerPolicy: {
      policy: config.security.headers.referrerPolicy as any,
    },

    // X-Frame-Options
    frameguard: {
      action: 'deny',
    },

    // Hide X-Powered-By header
    hidePoweredBy: true,

    // Disable X-Download-Options for IE8+
    ieNoOpen: true,

    // Don't cache DNS lookups
    dnsPrefetchControl: {
      allow: false,
    },

    // Permission Policy (formerly Feature Policy)
    permittedCrossDomainPolicies: false,
  });
}

/**
 * CORS middleware configuration
 * Configures Cross-Origin Resource Sharing with environment-specific origins
 */
export function corsMiddleware() {
  if (!config.security.cors.enabled) {
    return (req: Request, res: Response, next: NextFunction) => next();
  }

  return cors({
    origin: (origin, callback) => {
      // Allow requests with no origin (mobile apps, curl, etc.)
      if (!origin) {
        return callback(null, true);
      }

      // Check if origin is in allowed list
      if (config.security.cors.origins.length === 0 || 
          config.security.cors.origins.includes(origin)) {
        callback(null, true);
      } else {
        logger.warn('CORS blocked request from unauthorized origin', {
          origin,
          allowedOrigins: config.security.cors.origins,
        });
        callback(new Error('Not allowed by CORS'), false);
      }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: [
      'Origin',
      'X-Requested-With',
      'Content-Type',
      'Accept',
      'Authorization',
      'X-API-Key',
    ],
    exposedHeaders: ['X-Total-Count', 'X-Request-ID'],
    maxAge: 86400, // 24 hours
  });
}

/**
 * Rate limiting middleware
 * Prevents abuse and DoS attacks
 */
export function rateLimitMiddleware() {
  if (!config.security.rateLimit.enabled) {
    return (req: Request, res: Response, next: NextFunction) => next();
  }

  return rateLimit({
    windowMs: config.security.rateLimit.windowMs,
    max: config.security.rateLimit.max,
    message: {
      error: 'Too many requests',
      message: 'Rate limit exceeded. Please try again later.',
      retryAfter: Math.ceil(config.security.rateLimit.windowMs / 1000),
    },
    standardHeaders: true,
    legacyHeaders: false,
    
    // Custom key generator for better rate limiting
    keyGenerator: (req: Request): string => {
      // Use forwarded IP if available (for proxy environments)
      const forwarded = req.get('X-Forwarded-For');
      const ip = forwarded ? forwarded.split(',')[0].trim() : req.ip;
      
      // Include user agent in key for more granular limiting
      const userAgent = req.get('User-Agent') || 'unknown';
      const userAgentHash = Buffer.from(userAgent).toString('base64').substring(0, 8);
      
      return `${ip}:${userAgentHash}`;
    },

    // Skip rate limiting for health checks
    skip: (req: Request): boolean => {
      return req.path === config.health.path;
    },

    onLimitReached: (req: Request, res: Response): void => {
      logger.warn('Rate limit exceeded', {
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        path: req.path,
        method: req.method,
      });
    },
  });
}

/**
 * Request logging middleware for security auditing
 */
export function securityLogging(req: Request, res: Response, next: NextFunction): void {
  // Log suspicious requests
  const suspicious = [
    req.path.includes('..'),
    req.path.includes('<script'),
    req.path.includes('DROP TABLE'),
    req.path.includes('UNION SELECT'),
    req.get('User-Agent')?.includes('sqlmap'),
    req.get('User-Agent')?.includes('nmap'),
  ].some(Boolean);

  if (suspicious) {
    logger.warn('Suspicious request detected', {
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      path: req.path,
      method: req.method,
      headers: req.headers,
      query: req.query,
    });
  }

  // Log all POST/PUT/DELETE requests for audit trail
  if (['POST', 'PUT', 'DELETE'].includes(req.method)) {
    logger.info('Modifying request', {
      ip: req.ip,
      method: req.method,
      path: req.path,
      userAgent: req.get('User-Agent'),
    });
  }

  next();
}

/**
 * Content validation middleware
 * Validates request content types and sizes
 */
export function contentValidation(req: Request, res: Response, next: NextFunction): void {
  // Validate content-type for POST/PUT requests
  if (['POST', 'PUT'].includes(req.method)) {
    const contentType = req.get('Content-Type');
    
    if (!contentType) {
      return res.status(400).json({
        error: 'Missing Content-Type header',
        message: 'Content-Type header is required for POST/PUT requests',
      });
    }

    // Only allow JSON for API requests
    if (!contentType.includes('application/json')) {
      return res.status(415).json({
        error: 'Unsupported Media Type',
        message: 'Only application/json is supported',
      });
    }
  }

  next();
}

/**
 * Apply all security middleware to Express app
 */
export function applySecurityMiddleware(app: any): void {
  // Request ID for tracing
  app.use((req: Request, res: Response, next: NextFunction) => {
    req.id = Math.random().toString(36).substring(2, 15);
    res.set('X-Request-ID', req.id);
    next();
  });

  // HTTPS enforcement (must be first)
  app.use(httpsEnforcement);

  // Security headers
  app.use(securityHeaders());

  // CORS
  app.use(corsMiddleware());

  // Rate limiting
  app.use(rateLimitMiddleware());

  // Security logging
  app.use(securityLogging);

  // Content validation
  app.use(contentValidation);

  logger.info('Security middleware applied', {
    httpsOnly: config.security.httpsOnly,
    corsEnabled: config.security.cors.enabled,
    rateLimitEnabled: config.security.rateLimit.enabled,
    headersEnabled: config.security.headers.enabled,
  });
}

// Extend Express Request interface for TypeScript
declare global {
  namespace Express {
    interface Request {
      id?: string;
    }
  }
}