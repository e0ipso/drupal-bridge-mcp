76f7c1fddd6fd9512519501638669c17
"use strict";
/**
 * OAuth 2.0 Client with PKCE implementation for Drupal Simple OAuth 5.x
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuthClient = void 0;
const crypto_1 = require("crypto");
const http_1 = require("http");
const url_1 = require("url");
/**
 * OAuth 2.0 client with PKCE support for terminal environments
 */
class OAuthClient {
    config;
    server;
    constructor(config) {
        this.config = config;
    }
    /**
     * Generate PKCE code verifier and challenge
     */
    generatePKCEChallenge() {
        const codeVerifier = (0, crypto_1.randomBytes)(32).toString('base64url');
        const codeChallenge = (0, crypto_1.createHash)('sha256')
            .update(codeVerifier)
            .digest('base64url');
        return {
            codeVerifier,
            codeChallenge,
            codeChallengeMethod: 'S256',
        };
    }
    /**
     * Start OAuth authorization flow
     */
    async authorize() {
        const pkce = this.generatePKCEChallenge();
        const state = (0, crypto_1.randomBytes)(16).toString('hex');
        try {
            // Try localhost server first
            const authCode = await this.authorizeWithServer(pkce, state);
            return await this.exchangeCodeForTokens(authCode, pkce.codeVerifier);
        }
        catch (error) {
            console.error('Localhost server failed, falling back to manual entry:', error);
            return await this.authorizeManually(pkce, state);
        }
    }
    /**
     * OAuth flow using localhost HTTP server
     */
    async authorizeWithServer(pkce, state) {
        const FALLBACK_PORTS = [3000, 3001, 0]; // 0 = OS-assigned
        for (const port of FALLBACK_PORTS) {
            try {
                const server = await this.createAuthServer(state);
                const serverPort = await this.startServer(server, port);
                const authUrl = this.buildAuthorizationUrl({
                    ...pkce,
                    state,
                    redirectUri: `http://127.0.0.1:${serverPort}/callback`,
                });
                console.log(`Opening authorization URL: ${authUrl}`);
                try {
                    const { default: open } = await Promise.resolve().then(() => __importStar(require('open')));
                    await open(authUrl);
                }
                catch {
                    console.log('Browser auto-open failed. Please manually open the URL above.');
                }
                const authCode = await this.waitForAuthCode(server);
                return authCode;
            }
            catch (error) {
                if (port === FALLBACK_PORTS[FALLBACK_PORTS.length - 1]) {
                    throw error;
                }
                continue;
            }
        }
        throw new Error('All ports failed');
    }
    /**
     * Manual OAuth flow for restricted environments
     */
    async authorizeManually(pkce, state) {
        const authUrl = this.buildAuthorizationUrl({
            ...pkce,
            state,
            redirectUri: this.config.redirectUri,
        });
        console.log('\n=== Manual Authorization Required ===');
        console.log('1. Open this URL in your browser:');
        console.log(`   ${authUrl}`);
        console.log('2. Complete authorization');
        console.log('3. Copy the authorization code from the response');
        console.log('=====================================\n');
        // In a real implementation, you'd prompt for user input here
        // For this example, we'll throw an error to indicate manual intervention needed
        throw new Error('Manual authorization code entry required');
    }
    /**
     * Create HTTP server for OAuth callback
     */
    createAuthServer(expectedState) {
        return new Promise((resolve, reject) => {
            const server = (0, http_1.createServer)((req, res) => {
                const url = (0, url_1.parse)(req.url || '', true);
                if (url.pathname === '/callback') {
                    const { code, state, error } = url.query;
                    if (error) {
                        res.writeHead(400, { 'Content-Type': 'text/html' });
                        res.end(`<html><body><h1>Authorization Failed</h1><p>Error: ${error}</p></body></html>`);
                        return;
                    }
                    if (state !== expectedState) {
                        res.writeHead(400, { 'Content-Type': 'text/html' });
                        res.end('<html><body><h1>Authorization Failed</h1><p>Invalid state parameter</p></body></html>');
                        return;
                    }
                    if (code) {
                        res.writeHead(200, { 'Content-Type': 'text/html' });
                        res.end('<html><body><h1>Authorization Successful</h1><p>You can close this window.</p></body></html>');
                        const authCode = Array.isArray(code) ? code[0] : code;
                        server.authCode =
                            authCode;
                        server.close();
                    }
                }
                else {
                    res.writeHead(404);
                    res.end('Not found');
                }
            });
            server.on('error', reject);
            resolve(server);
        });
    }
    /**
     * Start server on specified port
     */
    startServer(server, port) {
        return new Promise((resolve, reject) => {
            server.listen(port, '127.0.0.1', () => {
                const address = server.address();
                if (address && typeof address === 'object') {
                    resolve(address.port);
                }
                else {
                    reject(new Error('Failed to get server port'));
                }
            });
            server.on('error', reject);
        });
    }
    /**
     * Wait for authorization code from callback
     */
    waitForAuthCode(server) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                server.close();
                reject(new Error('Authorization timeout'));
            }, 120000); // 2 minutes
            server.on('close', () => {
                clearTimeout(timeout);
                const { authCode } = server;
                if (authCode) {
                    resolve(authCode);
                }
                else {
                    reject(new Error('No authorization code received'));
                }
            });
        });
    }
    /**
     * Build authorization URL with PKCE parameters
     */
    buildAuthorizationUrl(params) {
        const url = new URL(this.config.authorizationEndpoint);
        url.searchParams.set('response_type', 'code');
        url.searchParams.set('client_id', this.config.clientId);
        url.searchParams.set('redirect_uri', params.redirectUri);
        url.searchParams.set('scope', this.config.scopes.join(' '));
        url.searchParams.set('state', params.state);
        url.searchParams.set('code_challenge', params.codeChallenge);
        url.searchParams.set('code_challenge_method', params.codeChallengeMethod);
        return url.toString();
    }
    /**
     * Exchange authorization code for access tokens
     */
    async exchangeCodeForTokens(code, codeVerifier) {
        const fetch = globalThis.fetch || (await Promise.resolve().then(() => __importStar(require('node-fetch')))).default;
        const body = new URLSearchParams({
            grant_type: 'authorization_code',
            client_id: this.config.clientId,
            code,
            redirect_uri: this.config.redirectUri,
            code_verifier: codeVerifier,
        });
        const response = await fetch(this.config.tokenEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json',
            },
            body: body.toString(),
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Token exchange failed: ${response.status} ${errorText}`);
        }
        const tokenData = await response.json();
        return {
            accessToken: tokenData.access_token,
            refreshToken: tokenData.refresh_token,
            tokenType: tokenData.token_type || 'Bearer',
            expiresIn: tokenData.expires_in,
            scope: tokenData.scope,
        };
    }
    /**
     * Refresh access token using refresh token
     */
    async refreshToken(refreshToken) {
        const fetch = globalThis.fetch || (await Promise.resolve().then(() => __importStar(require('node-fetch')))).default;
        const body = new URLSearchParams({
            grant_type: 'refresh_token',
            client_id: this.config.clientId,
            refresh_token: refreshToken,
        });
        const response = await fetch(this.config.tokenEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                Accept: 'application/json',
            },
            body: body.toString(),
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Token refresh failed: ${response.status} ${errorText}`);
        }
        const tokenData = await response.json();
        return {
            accessToken: tokenData.access_token,
            refreshToken: tokenData.refresh_token || refreshToken, // Keep old if new not provided
            tokenType: tokenData.token_type || 'Bearer',
            expiresIn: tokenData.expires_in,
            scope: tokenData.scope,
        };
    }
}
exports.OAuthClient = OAuthClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztRQUVELE1BQU0sU0FBUyxHQUFHLE1BQU0sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRXhDLE9BQU87WUFDTCxXQUFXLEVBQUUsU0FBUyxDQUFDLFlBQVk7WUFDbkMsWUFBWSxFQUFFLFNBQVMsQ0FBQyxhQUFhLElBQUksWUFBWSxFQUFFLCtCQUErQjtZQUN0RixTQUFTLEVBQUUsU0FBUyxDQUFDLFVBQVUsSUFBSSxRQUFRO1lBQzNDLFNBQVMsRUFBRSxTQUFTLENBQUMsVUFBVTtZQUMvQixLQUFLLEVBQUUsU0FBUyxDQUFDLEtBQUs7U0FDdkIsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQTNTRCxrQ0EyU0MiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL3dvcmtzcGFjZS9zcmMvYXV0aC9vYXV0aC1jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPQXV0aCAyLjAgQ2xpZW50IHdpdGggUEtDRSBpbXBsZW1lbnRhdGlvbiBmb3IgRHJ1cGFsIFNpbXBsZSBPQXV0aCA1LnhcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVIYXNoLCByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgdHlwZSB7IFNlcnZlciB9IGZyb20gJ2h0dHAnO1xuaW1wb3J0IHsgY3JlYXRlU2VydmVyIH0gZnJvbSAnaHR0cCc7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJ3VybCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT0F1dGhDb25maWcge1xuICBjbGllbnRJZDogc3RyaW5nO1xuICBhdXRob3JpemF0aW9uRW5kcG9pbnQ6IHN0cmluZztcbiAgdG9rZW5FbmRwb2ludDogc3RyaW5nO1xuICByZWRpcmVjdFVyaTogc3RyaW5nO1xuICBzY29wZXM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9BdXRoVG9rZW5zIHtcbiAgYWNjZXNzVG9rZW46IHN0cmluZztcbiAgcmVmcmVzaFRva2VuPzogc3RyaW5nO1xuICB0b2tlblR5cGU6IHN0cmluZztcbiAgZXhwaXJlc0luPzogbnVtYmVyO1xuICBzY29wZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQS0NFQ2hhbGxlbmdlIHtcbiAgY29kZVZlcmlmaWVyOiBzdHJpbmc7XG4gIGNvZGVDaGFsbGVuZ2U6IHN0cmluZztcbiAgY29kZUNoYWxsZW5nZU1ldGhvZDogJ1MyNTYnO1xufVxuXG4vKipcbiAqIE9BdXRoIDIuMCBjbGllbnQgd2l0aCBQS0NFIHN1cHBvcnQgZm9yIHRlcm1pbmFsIGVudmlyb25tZW50c1xuICovXG5leHBvcnQgY2xhc3MgT0F1dGhDbGllbnQge1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogT0F1dGhDb25maWc7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2VydmVyPzogU2VydmVyO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogT0F1dGhDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBQS0NFIGNvZGUgdmVyaWZpZXIgYW5kIGNoYWxsZW5nZVxuICAgKi9cbiAgZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlKCk6IFBLQ0VDaGFsbGVuZ2Uge1xuICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IHJhbmRvbUJ5dGVzKDMyKS50b1N0cmluZygnYmFzZTY0dXJsJyk7XG4gICAgY29uc3QgY29kZUNoYWxsZW5nZSA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAudXBkYXRlKGNvZGVWZXJpZmllcilcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NHVybCcpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGVWZXJpZmllcixcbiAgICAgIGNvZGVDaGFsbGVuZ2UsXG4gICAgICBjb2RlQ2hhbGxlbmdlTWV0aG9kOiAnUzI1NicsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBPQXV0aCBhdXRob3JpemF0aW9uIGZsb3dcbiAgICovXG4gIGFzeW5jIGF1dGhvcml6ZSgpOiBQcm9taXNlPE9BdXRoVG9rZW5zPiB7XG4gICAgY29uc3QgcGtjZSA9IHRoaXMuZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSByYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyeSBsb2NhbGhvc3Qgc2VydmVyIGZpcnN0XG4gICAgICBjb25zdCBhdXRoQ29kZSA9IGF3YWl0IHRoaXMuYXV0aG9yaXplV2l0aFNlcnZlcihwa2NlLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5leGNoYW5nZUNvZGVGb3JUb2tlbnMoYXV0aENvZGUsIHBrY2UuY29kZVZlcmlmaWVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ0xvY2FsaG9zdCBzZXJ2ZXIgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gbWFudWFsIGVudHJ5OicsXG4gICAgICAgIGVycm9yXG4gICAgICApO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYXV0aG9yaXplTWFudWFsbHkocGtjZSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPQXV0aCBmbG93IHVzaW5nIGxvY2FsaG9zdCBIVFRQIHNlcnZlclxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBhdXRob3JpemVXaXRoU2VydmVyKFxuICAgIHBrY2U6IFBLQ0VDaGFsbGVuZ2UsXG4gICAgc3RhdGU6IHN0cmluZ1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IEZBTExCQUNLX1BPUlRTID0gWzMwMDAsIDMwMDEsIDBdOyAvLyAwID0gT1MtYXNzaWduZWRcblxuICAgIGZvciAoY29uc3QgcG9ydCBvZiBGQUxMQkFDS19QT1JUUykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5jcmVhdGVBdXRoU2VydmVyKHN0YXRlKTtcbiAgICAgICAgY29uc3Qgc2VydmVyUG9ydCA9IGF3YWl0IHRoaXMuc3RhcnRTZXJ2ZXIoc2VydmVyLCBwb3J0KTtcblxuICAgICAgICBjb25zdCBhdXRoVXJsID0gdGhpcy5idWlsZEF1dGhvcml6YXRpb25Vcmwoe1xuICAgICAgICAgIC4uLnBrY2UsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcmVkaXJlY3RVcmk6IGBodHRwOi8vMTI3LjAuMC4xOiR7c2VydmVyUG9ydH0vY2FsbGJhY2tgLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgT3BlbmluZyBhdXRob3JpemF0aW9uIFVSTDogJHthdXRoVXJsfWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgZGVmYXVsdDogb3BlbiB9ID0gYXdhaXQgaW1wb3J0KCdvcGVuJyk7XG4gICAgICAgICAgYXdhaXQgb3BlbihhdXRoVXJsKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAnQnJvd3NlciBhdXRvLW9wZW4gZmFpbGVkLiBQbGVhc2UgbWFudWFsbHkgb3BlbiB0aGUgVVJMIGFib3ZlLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXV0aENvZGUgPSBhd2FpdCB0aGlzLndhaXRGb3JBdXRoQ29kZShzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gYXV0aENvZGU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAocG9ydCA9PT0gRkFMTEJBQ0tfUE9SVFNbRkFMTEJBQ0tfUE9SVFMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBwb3J0cyBmYWlsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYW51YWwgT0F1dGggZmxvdyBmb3IgcmVzdHJpY3RlZCBlbnZpcm9ubWVudHNcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgYXV0aG9yaXplTWFudWFsbHkoXG4gICAgcGtjZTogUEtDRUNoYWxsZW5nZSxcbiAgICBzdGF0ZTogc3RyaW5nXG4gICk6IFByb21pc2U8T0F1dGhUb2tlbnM+IHtcbiAgICBjb25zdCBhdXRoVXJsID0gdGhpcy5idWlsZEF1dGhvcml6YXRpb25Vcmwoe1xuICAgICAgLi4ucGtjZSxcbiAgICAgIHN0YXRlLFxuICAgICAgcmVkaXJlY3RVcmk6IHRoaXMuY29uZmlnLnJlZGlyZWN0VXJpLFxuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coJ1xcbj09PSBNYW51YWwgQXV0aG9yaXphdGlvbiBSZXF1aXJlZCA9PT0nKTtcbiAgICBjb25zb2xlLmxvZygnMS4gT3BlbiB0aGlzIFVSTCBpbiB5b3VyIGJyb3dzZXI6Jyk7XG4gICAgY29uc29sZS5sb2coYCAgICR7YXV0aFVybH1gKTtcbiAgICBjb25zb2xlLmxvZygnMi4gQ29tcGxldGUgYXV0aG9yaXphdGlvbicpO1xuICAgIGNvbnNvbGUubG9nKCczLiBDb3B5IHRoZSBhdXRob3JpemF0aW9uIGNvZGUgZnJvbSB0aGUgcmVzcG9uc2UnKTtcbiAgICBjb25zb2xlLmxvZygnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbicpO1xuXG4gICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB5b3UnZCBwcm9tcHQgZm9yIHVzZXIgaW5wdXQgaGVyZVxuICAgIC8vIEZvciB0aGlzIGV4YW1wbGUsIHdlJ2xsIHRocm93IGFuIGVycm9yIHRvIGluZGljYXRlIG1hbnVhbCBpbnRlcnZlbnRpb24gbmVlZGVkXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYW51YWwgYXV0aG9yaXphdGlvbiBjb2RlIGVudHJ5IHJlcXVpcmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIEhUVFAgc2VydmVyIGZvciBPQXV0aCBjYWxsYmFja1xuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVBdXRoU2VydmVyKGV4cGVjdGVkU3RhdGU6IHN0cmluZyk6IFByb21pc2U8U2VydmVyPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IGNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgY29uc3QgdXJsID0gcGFyc2UocmVxLnVybCB8fCAnJywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHVybC5wYXRobmFtZSA9PT0gJy9jYWxsYmFjaycpIHtcbiAgICAgICAgICBjb25zdCB7IGNvZGUsIHN0YXRlLCBlcnJvciB9ID0gdXJsLnF1ZXJ5O1xuXG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkKDQwMCwgeyAnQ29udGVudC1UeXBlJzogJ3RleHQvaHRtbCcgfSk7XG4gICAgICAgICAgICByZXMuZW5kKFxuICAgICAgICAgICAgICBgPGh0bWw+PGJvZHk+PGgxPkF1dGhvcml6YXRpb24gRmFpbGVkPC9oMT48cD5FcnJvcjogJHtlcnJvcn08L3A+PC9ib2R5PjwvaHRtbD5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZSAhPT0gZXhwZWN0ZWRTdGF0ZSkge1xuICAgICAgICAgICAgcmVzLndyaXRlSGVhZCg0MDAsIHsgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnIH0pO1xuICAgICAgICAgICAgcmVzLmVuZChcbiAgICAgICAgICAgICAgJzxodG1sPjxib2R5PjxoMT5BdXRob3JpemF0aW9uIEZhaWxlZDwvaDE+PHA+SW52YWxpZCBzdGF0ZSBwYXJhbWV0ZXI8L3A+PC9ib2R5PjwvaHRtbD4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCwgeyAnQ29udGVudC1UeXBlJzogJ3RleHQvaHRtbCcgfSk7XG4gICAgICAgICAgICByZXMuZW5kKFxuICAgICAgICAgICAgICAnPGh0bWw+PGJvZHk+PGgxPkF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bDwvaDE+PHA+WW91IGNhbiBjbG9zZSB0aGlzIHdpbmRvdy48L3A+PC9ib2R5PjwvaHRtbD4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgYXV0aENvZGUgPSBBcnJheS5pc0FycmF5KGNvZGUpID8gY29kZVswXSA6IGNvZGU7XG4gICAgICAgICAgICAoc2VydmVyIGFzIHR5cGVvZiBzZXJ2ZXIgJiB7IGF1dGhDb2RlPzogc3RyaW5nIH0pLmF1dGhDb2RlID1cbiAgICAgICAgICAgICAgYXV0aENvZGU7XG4gICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzLndyaXRlSGVhZCg0MDQpO1xuICAgICAgICAgIHJlcy5lbmQoJ05vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2VydmVyLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICByZXNvbHZlKHNlcnZlcik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgc2VydmVyIG9uIHNwZWNpZmllZCBwb3J0XG4gICAqL1xuICBwcml2YXRlIHN0YXJ0U2VydmVyKHNlcnZlcjogU2VydmVyLCBwb3J0OiBudW1iZXIpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzZXJ2ZXIubGlzdGVuKHBvcnQsICcxMjcuMC4wLjEnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBzZXJ2ZXIuYWRkcmVzcygpO1xuICAgICAgICBpZiAoYWRkcmVzcyAmJiB0eXBlb2YgYWRkcmVzcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXNvbHZlKGFkZHJlc3MucG9ydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBzZXJ2ZXIgcG9ydCcpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNlcnZlci5vbignZXJyb3InLCByZWplY3QpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXQgZm9yIGF1dGhvcml6YXRpb24gY29kZSBmcm9tIGNhbGxiYWNrXG4gICAqL1xuICBwcml2YXRlIHdhaXRGb3JBdXRoQ29kZShzZXJ2ZXI6IFNlcnZlcik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2VydmVyLmNsb3NlKCk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0F1dGhvcml6YXRpb24gdGltZW91dCcpKTtcbiAgICAgIH0sIDEyMDAwMCk7IC8vIDIgbWludXRlc1xuXG4gICAgICBzZXJ2ZXIub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGNvbnN0IHsgYXV0aENvZGUgfSA9IHNlcnZlciBhcyB0eXBlb2Ygc2VydmVyICYgeyBhdXRoQ29kZT86IHN0cmluZyB9O1xuICAgICAgICBpZiAoYXV0aENvZGUpIHtcbiAgICAgICAgICByZXNvbHZlKGF1dGhDb2RlIGFzIHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm8gYXV0aG9yaXphdGlvbiBjb2RlIHJlY2VpdmVkJykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhdXRob3JpemF0aW9uIFVSTCB3aXRoIFBLQ0UgcGFyYW1ldGVyc1xuICAgKi9cbiAgcHJpdmF0ZSBidWlsZEF1dGhvcml6YXRpb25VcmwocGFyYW1zOiB7XG4gICAgY29kZUNoYWxsZW5nZTogc3RyaW5nO1xuICAgIGNvZGVDaGFsbGVuZ2VNZXRob2Q6IHN0cmluZztcbiAgICBzdGF0ZTogc3RyaW5nO1xuICAgIHJlZGlyZWN0VXJpOiBzdHJpbmc7XG4gIH0pOiBzdHJpbmcge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy5jb25maWcuYXV0aG9yaXphdGlvbkVuZHBvaW50KTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgncmVzcG9uc2VfdHlwZScsICdjb2RlJyk7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NsaWVudF9pZCcsIHRoaXMuY29uZmlnLmNsaWVudElkKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgncmVkaXJlY3RfdXJpJywgcGFyYW1zLnJlZGlyZWN0VXJpKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnc2NvcGUnLCB0aGlzLmNvbmZpZy5zY29wZXMuam9pbignICcpKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnc3RhdGUnLCBwYXJhbXMuc3RhdGUpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2RlX2NoYWxsZW5nZScsIHBhcmFtcy5jb2RlQ2hhbGxlbmdlKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnY29kZV9jaGFsbGVuZ2VfbWV0aG9kJywgcGFyYW1zLmNvZGVDaGFsbGVuZ2VNZXRob2QpO1xuXG4gICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4Y2hhbmdlIGF1dGhvcml6YXRpb24gY29kZSBmb3IgYWNjZXNzIHRva2Vuc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBleGNoYW5nZUNvZGVGb3JUb2tlbnMoXG4gICAgY29kZTogc3RyaW5nLFxuICAgIGNvZGVWZXJpZmllcjogc3RyaW5nXG4gICk6IFByb21pc2U8T0F1dGhUb2tlbnM+IHtcbiAgICBjb25zdCBmZXRjaCA9IGdsb2JhbFRoaXMuZmV0Y2ggfHwgKGF3YWl0IGltcG9ydCgnbm9kZS1mZXRjaCcpKS5kZWZhdWx0O1xuXG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgZ3JhbnRfdHlwZTogJ2F1dGhvcml6YXRpb25fY29kZScsXG4gICAgICBjbGllbnRfaWQ6IHRoaXMuY29uZmlnLmNsaWVudElkLFxuICAgICAgY29kZSxcbiAgICAgIHJlZGlyZWN0X3VyaTogdGhpcy5jb25maWcucmVkaXJlY3RVcmksXG4gICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuY29uZmlnLnRva2VuRW5kcG9pbnQsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IGJvZHkudG9TdHJpbmcoKSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW4gZXhjaGFuZ2UgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtlcnJvclRleHR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW5EYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY2Vzc1Rva2VuOiB0b2tlbkRhdGEuYWNjZXNzX3Rva2VuLFxuICAgICAgcmVmcmVzaFRva2VuOiB0b2tlbkRhdGEucmVmcmVzaF90b2tlbixcbiAgICAgIHRva2VuVHlwZTogdG9rZW5EYXRhLnRva2VuX3R5cGUgfHwgJ0JlYXJlcicsXG4gICAgICBleHBpcmVzSW46IHRva2VuRGF0YS5leHBpcmVzX2luLFxuICAgICAgc2NvcGU6IHRva2VuRGF0YS5zY29wZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggYWNjZXNzIHRva2VuIHVzaW5nIHJlZnJlc2ggdG9rZW5cbiAgICovXG4gIGFzeW5jIHJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW46IHN0cmluZyk6IFByb21pc2U8T0F1dGhUb2tlbnM+IHtcbiAgICBjb25zdCBmZXRjaCA9IGdsb2JhbFRoaXMuZmV0Y2ggfHwgKGF3YWl0IGltcG9ydCgnbm9kZS1mZXRjaCcpKS5kZWZhdWx0O1xuXG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgY2xpZW50X2lkOiB0aGlzLmNvbmZpZy5jbGllbnRJZCxcbiAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5jb25maWcudG9rZW5FbmRwb2ludCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogYm9keS50b1N0cmluZygpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb2tlbiByZWZyZXNoIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7ZXJyb3JUZXh0fWApO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VuRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICBhY2Nlc3NUb2tlbjogdG9rZW5EYXRhLmFjY2Vzc190b2tlbixcbiAgICAgIHJlZnJlc2hUb2tlbjogdG9rZW5EYXRhLnJlZnJlc2hfdG9rZW4gfHwgcmVmcmVzaFRva2VuLCAvLyBLZWVwIG9sZCBpZiBuZXcgbm90IHByb3ZpZGVkXG4gICAgICB0b2tlblR5cGU6IHRva2VuRGF0YS50b2tlbl90eXBlIHx8ICdCZWFyZXInLFxuICAgICAgZXhwaXJlc0luOiB0b2tlbkRhdGEuZXhwaXJlc19pbixcbiAgICAgIHNjb3BlOiB0b2tlbkRhdGEuc2NvcGUsXG4gICAgfTtcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9