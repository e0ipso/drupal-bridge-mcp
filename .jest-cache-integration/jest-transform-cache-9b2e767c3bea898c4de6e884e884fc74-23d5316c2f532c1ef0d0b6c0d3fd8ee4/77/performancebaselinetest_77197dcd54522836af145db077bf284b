6c9963d01b2c3eb002557022f842bf10
"use strict";
/**
 * Performance baseline tests for the JSON-RPC Drupal integration
 * These tests establish performance metrics for future optimization reference
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const server_js_1 = require("@/mcp/server.js");
const drupal_client_js_1 = require("@/services/drupal-client.js");
// Mock fetch for consistent performance testing
const mockFetch = globals_1.jest.fn();
global.fetch = mockFetch;
(0, globals_1.describe)('Performance Baseline Measurements', () => {
    let config;
    let mcpServer;
    let drupalClient;
    (0, globals_1.beforeEach)(async () => {
        config = {
            drupal: {
                baseUrl: 'http://localhost/drupal',
                endpoint: '/jsonrpc',
                timeout: 10000,
                retries: 3,
                headers: {
                    'Content-Type': 'application/json',
                    Accept: 'application/json',
                },
            },
            oauth: {
                clientId: 'test-client-id',
                authorizationEndpoint: 'http://localhost/drupal/oauth/authorize',
                tokenEndpoint: 'http://localhost/drupal/oauth/token',
                redirectUri: 'http://127.0.0.1:3000/callback',
                scopes: ['tutorial:read', 'user:profile'],
            },
            auth: {
                enabled: false, // Disable auth for performance tests
                requiredScopes: ['tutorial:read'],
                skipAuth: true,
            },
            mcp: {
                name: 'test-drupal-bridge-mcp',
                version: '1.0.0-test',
                protocolVersion: '2024-11-05',
                capabilities: {
                    resources: { subscribe: true, listChanged: true },
                    tools: { listChanged: true },
                    prompts: { listChanged: true },
                },
            },
            server: {
                port: 3000,
                host: '0.0.0.0',
            },
            logging: {
                level: 'error',
            },
            environment: 'test',
        };
        mcpServer = new server_js_1.DrupalMcpServer(config);
        drupalClient = new drupal_client_js_1.DrupalClient(config.drupal);
        globals_1.jest.clearAllMocks();
        // Force garbage collection if available for more accurate memory measurements
        if (global.gc) {
            global.gc();
        }
    });
    (0, globals_1.afterEach)(() => {
        globals_1.jest.restoreAllMocks();
    });
    /**
     * Measure performance of a function
     */
    async function measurePerformance(operation, warmupRuns = 3, measureRuns = 10) {
        // Warmup runs to stabilize JIT compilation
        for (let i = 0; i < warmupRuns; i++) {
            await operation();
        }
        // Force garbage collection before measurement
        if (global.gc) {
            global.gc();
        }
        const initialMemory = process.memoryUsage();
        const startTime = process.hrtime.bigint();
        let result;
        for (let i = 0; i < measureRuns; i++) {
            result = await operation();
        }
        const endTime = process.hrtime.bigint();
        const finalMemory = process.memoryUsage();
        const executionTime = Number(endTime - startTime) / 1_000_000; // Convert to milliseconds
        const memoryUsage = {
            heapUsed: finalMemory.heapUsed - initialMemory.heapUsed,
            heapTotal: finalMemory.heapTotal - initialMemory.heapTotal,
            external: finalMemory.external - initialMemory.external,
        };
        return {
            result: result,
            metrics: {
                executionTime: executionTime / measureRuns, // Average execution time
                memoryUsage,
            },
        };
    }
    /**
     * Run benchmark with multiple iterations and collect statistics
     */
    async function runBenchmark(name, operation, iterations = 100) {
        const times = [];
        const initialMemory = process.memoryUsage().heapUsed;
        console.log(`Starting benchmark: ${name} (${iterations} iterations)`);
        const startTime = Date.now();
        for (let i = 0; i < iterations; i++) {
            const iterationStart = process.hrtime.bigint();
            await operation();
            const iterationEnd = process.hrtime.bigint();
            times.push(Number(iterationEnd - iterationStart) / 1_000_000);
        }
        const totalTime = Date.now() - startTime;
        const finalMemory = process.memoryUsage().heapUsed;
        const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
        const minTime = Math.min(...times);
        const maxTime = Math.max(...times);
        const memoryDelta = finalMemory - initialMemory;
        const throughput = (iterations * 1000) / totalTime;
        const result = {
            operation: name,
            iterations,
            avgTime,
            minTime,
            maxTime,
            memoryDelta,
            throughput,
        };
        console.log(`Benchmark ${name} completed:`);
        console.log(`  Average time: ${avgTime.toFixed(2)}ms`);
        console.log(`  Min time: ${minTime.toFixed(2)}ms`);
        console.log(`  Max time: ${maxTime.toFixed(2)}ms`);
        console.log(`  Memory delta: ${Math.round(memoryDelta / 1024)}KB`);
        console.log(`  Throughput: ${throughput.toFixed(2)} ops/sec`);
        console.log('');
        return result;
    }
    (0, globals_1.describe)('Search Operation Performance', () => {
        (0, globals_1.test)('should benchmark basic search tutorial operation', async () => {
            const benchmark = await runBenchmark('Basic Search Tutorial', async () => {
                return await mcpServer.executeSearchTutorials({
                    keywords: 'forms',
                });
            }, 50);
            // Performance expectations (baseline measurements)
            (0, globals_1.expect)(benchmark.avgTime).toBeLessThan(10); // Should average less than 10ms in test mode
            (0, globals_1.expect)(benchmark.throughput).toBeGreaterThan(50); // Should handle at least 50 ops/sec
            (0, globals_1.expect)(benchmark.memoryDelta).toBeLessThan(10 * 1024 * 1024); // Less than 10MB memory increase
            // Store baseline metrics for future comparisons
            (0, globals_1.expect)(benchmark).toMatchObject({
                operation: 'Basic Search Tutorial',
                iterations: 50,
                avgTime: globals_1.expect.any(Number),
                minTime: globals_1.expect.any(Number),
                maxTime: globals_1.expect.any(Number),
                memoryDelta: globals_1.expect.any(Number),
                throughput: globals_1.expect.any(Number),
            });
        });
        (0, globals_1.test)('should benchmark search with filters', async () => {
            const benchmark = await runBenchmark('Filtered Search Tutorial', async () => {
                return await mcpServer.executeSearchTutorials({
                    keywords: 'content management',
                    drupal_version: ['10'],
                    category: ['tutorial', 'cms'],
                });
            }, 30);
            // Filtered searches might be slightly slower due to additional processing
            (0, globals_1.expect)(benchmark.avgTime).toBeLessThan(15);
            (0, globals_1.expect)(benchmark.throughput).toBeGreaterThan(30);
        });
        (0, globals_1.test)('should benchmark parameter validation performance', async () => {
            const { validateSearchContentParams } = await Promise.resolve().then(() => __importStar(require('@/utils/validation.js')));
            const benchmark = await runBenchmark('Parameter Validation', async () => {
                return validateSearchContentParams({
                    keywords: 'test validation performance',
                    drupal_version: ['11'],
                    category: ['performance', 'testing', 'validation'],
                });
            }, 1000);
            // Validation should be very fast
            (0, globals_1.expect)(benchmark.avgTime).toBeLessThan(1);
            (0, globals_1.expect)(benchmark.throughput).toBeGreaterThan(1000);
        });
    });
    (0, globals_1.describe)('MCP Tool Integration Performance', () => {
        (0, globals_1.test)('should benchmark MCP tool execution pipeline', async () => {
            const benchmark = await runBenchmark('MCP Tool Execution', async () => {
                return await mcpServer.executeTool('search_tutorials', {
                    keywords: 'mcp performance test',
                });
            }, 30);
            // MCP tool execution includes additional overhead for formatting
            (0, globals_1.expect)(benchmark.avgTime).toBeLessThan(20);
            (0, globals_1.expect)(benchmark.throughput).toBeGreaterThan(25);
        });
        (0, globals_1.test)('should benchmark error handling overhead', async () => {
            const benchmark = await runBenchmark('Error Handling', async () => {
                try {
                    return await mcpServer.executeTool('search_tutorials', {
                        keywords: 'x', // Will trigger validation error
                    });
                }
                catch (error) {
                    return error;
                }
            }, 100);
            // Error handling should add minimal overhead
            (0, globals_1.expect)(benchmark.avgTime).toBeLessThan(5);
            (0, globals_1.expect)(benchmark.throughput).toBeGreaterThan(100);
        });
    });
    (0, globals_1.describe)('Memory Usage Patterns', () => {
        (0, globals_1.test)('should measure memory usage for large response handling', async () => {
            const { result, metrics } = await measurePerformance(async () => {
                // Simulate processing large tutorial content
                const searchResult = await mcpServer.executeSearchTutorials({
                    keywords: 'large content test',
                });
                // Process and format multiple results
                return Array.from({ length: 100 }, (_, i) => ({
                    ...searchResult.results[0],
                    id: `${i}`,
                    title: `Large Tutorial ${i}`,
                    content: 'x'.repeat(10000), // 10KB of content per result
                }));
            });
            console.log('Large Response Memory Usage:');
            console.log(`  Execution time: ${metrics.executionTime.toFixed(2)}ms`);
            console.log(`  Heap used delta: ${Math.round(metrics.memoryUsage.heapUsed / 1024)}KB`);
            console.log(`  External memory delta: ${Math.round(metrics.memoryUsage.external / 1024)}KB`);
            (0, globals_1.expect)(result).toHaveLength(100);
            (0, globals_1.expect)(metrics.executionTime).toBeLessThan(50); // Should handle large content quickly
            (0, globals_1.expect)(metrics.memoryUsage.heapUsed).toBeLessThan(50 * 1024 * 1024); // Less than 50MB
        });
        (0, globals_1.test)('should measure memory usage for concurrent operations', async () => {
            const concurrentOperations = 10;
            const { result, metrics } = await measurePerformance(async () => {
                const promises = Array.from({ length: concurrentOperations }, (_, i) => mcpServer.executeSearchTutorials({
                    keywords: `concurrent test ${i}`,
                }));
                return await Promise.all(promises);
            });
            console.log(`Concurrent Operations Memory Usage (${concurrentOperations} operations):`);
            console.log(`  Execution time: ${metrics.executionTime.toFixed(2)}ms`);
            console.log(`  Memory delta: ${Math.round(metrics.memoryUsage.heapUsed / 1024)}KB`);
            (0, globals_1.expect)(result).toHaveLength(concurrentOperations);
            (0, globals_1.expect)(metrics.executionTime).toBeLessThan(100);
        });
    });
    (0, globals_1.describe)('Error Scenario Performance', () => {
        (0, globals_1.test)('should benchmark network timeout handling', async () => {
            // Mock network timeout
            mockFetch.mockImplementation(() => new Promise((_, reject) => {
                setTimeout(() => reject(new Error('timeout')), 10);
            }));
            const benchmark = await runBenchmark('Network Timeout Handling', async () => {
                try {
                    // Create client with short timeout for testing
                    const testClient = new drupal_client_js_1.DrupalClient({
                        ...config.drupal,
                        timeout: 50, // 50ms timeout
                        retries: 1, // Only 1 retry for faster testing
                    });
                    return await testClient.testConnection();
                }
                catch (error) {
                    return { error: true };
                }
            }, 10 // Fewer iterations due to timeouts
            );
            // Timeout handling should be reasonably fast
            (0, globals_1.expect)(benchmark.avgTime).toBeLessThan(100); // Should timeout quickly
        });
        (0, globals_1.test)('should benchmark JSON-RPC error response processing', async () => {
            // Mock JSON-RPC error response
            mockFetch.mockResolvedValue({
                status: 200,
                headers: new Map([['content-type', 'application/json']]),
                json: () => Promise.resolve({
                    jsonrpc: '2.0',
                    error: {
                        code: -32602,
                        message: 'Invalid parameters for testing',
                        data: { field: 'keywords', type: 'VALIDATION_ERROR' },
                    },
                    id: 'test-error',
                }),
            });
            const benchmark = await runBenchmark('JSON-RPC Error Processing', async () => {
                try {
                    return await drupalClient.searchTutorials({
                        keywords: 'error test',
                    });
                }
                catch (error) {
                    return { error: true };
                }
            }, 50);
            // Error processing should be fast
            (0, globals_1.expect)(benchmark.avgTime).toBeLessThan(20);
            (0, globals_1.expect)(benchmark.throughput).toBeGreaterThan(25);
        });
    });
    (0, globals_1.describe)('Performance Regression Detection', () => {
        (0, globals_1.test)('should establish baseline metrics for future comparison', () => {
            // This test documents the expected performance characteristics
            // Future test runs can compare against these baselines
            const performanceBaselines = {
                basicSearch: {
                    avgTime: 10, // ms
                    throughput: 50, // ops/sec
                    memoryPerOp: 1024, // bytes
                },
                filteredSearch: {
                    avgTime: 15, // ms
                    throughput: 30, // ops/sec
                },
                validation: {
                    avgTime: 1, // ms
                    throughput: 1000, // ops/sec
                },
                mcpToolExecution: {
                    avgTime: 20, // ms
                    throughput: 25, // ops/sec
                },
                errorHandling: {
                    avgTime: 5, // ms
                    throughput: 100, // ops/sec
                },
            };
            console.log('Performance Baselines Established:');
            console.log(JSON.stringify(performanceBaselines, null, 2));
            // Store baselines in test metadata
            (0, globals_1.expect)(performanceBaselines).toMatchSnapshot({
                basicSearch: {
                    avgTime: globals_1.expect.any(Number),
                    throughput: globals_1.expect.any(Number),
                    memoryPerOp: globals_1.expect.any(Number),
                },
                filteredSearch: {
                    avgTime: globals_1.expect.any(Number),
                    throughput: globals_1.expect.any(Number),
                },
                validation: {
                    avgTime: globals_1.expect.any(Number),
                    throughput: globals_1.expect.any(Number),
                },
                mcpToolExecution: {
                    avgTime: globals_1.expect.any(Number),
                    throughput: globals_1.expect.any(Number),
                },
                errorHandling: {
                    avgTime: globals_1.expect.any(Number),
                    throughput: globals_1.expect.any(Number),
                },
            });
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL3dvcmtzcGFjZS90ZXN0cy9pbnRlZ3JhdGlvbi9wZXJmb3JtYW5jZS1iYXNlbGluZS50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUgsMkNBT3VCO0FBQ3ZCLCtDQUFrRDtBQUNsRCxrRUFBMkQ7QUFHM0QsZ0RBQWdEO0FBQ2hELE1BQU0sU0FBUyxHQUFHLGNBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUM1QixNQUFNLENBQUMsS0FBSyxHQUFHLFNBQWdCLENBQUM7QUFzQmhDLElBQUEsa0JBQVEsRUFBQyxtQ0FBbUMsRUFBRSxHQUFHLEVBQUU7SUFDakQsSUFBSSxNQUFXLENBQUM7SUFDaEIsSUFBSSxTQUEwQixDQUFDO0lBQy9CLElBQUksWUFBMEIsQ0FBQztJQUUvQixJQUFBLG9CQUFVLEVBQUMsS0FBSyxJQUFJLEVBQUU7UUFDcEIsTUFBTSxHQUFHO1lBQ1AsTUFBTSxFQUFFO2dCQUNOLE9BQU8sRUFBRSx5QkFBeUI7Z0JBQ2xDLFFBQVEsRUFBRSxVQUFVO2dCQUNwQixPQUFPLEVBQUUsS0FBSztnQkFDZCxPQUFPLEVBQUUsQ0FBQztnQkFDVixPQUFPLEVBQUU7b0JBQ1AsY0FBYyxFQUFFLGtCQUFrQjtvQkFDbEMsTUFBTSxFQUFFLGtCQUFrQjtpQkFDM0I7YUFDRjtZQUNELEtBQUssRUFBRTtnQkFDTCxRQUFRLEVBQUUsZ0JBQWdCO2dCQUMxQixxQkFBcUIsRUFBRSx5Q0FBeUM7Z0JBQ2hFLGFBQWEsRUFBRSxxQ0FBcUM7Z0JBQ3BELFdBQVcsRUFBRSxnQ0FBZ0M7Z0JBQzdDLE1BQU0sRUFBRSxDQUFDLGVBQWUsRUFBRSxjQUFjLENBQUM7YUFDMUM7WUFDRCxJQUFJLEVBQUU7Z0JBQ0osT0FBTyxFQUFFLEtBQUssRUFBRSxxQ0FBcUM7Z0JBQ3JELGNBQWMsRUFBRSxDQUFDLGVBQWUsQ0FBQztnQkFDakMsUUFBUSxFQUFFLElBQUk7YUFDZjtZQUNELEdBQUcsRUFBRTtnQkFDSCxJQUFJLEVBQUUs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L3BlcmZvcm1hbmNlLWJhc2VsaW5lLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJmb3JtYW5jZSBiYXNlbGluZSB0ZXN0cyBmb3IgdGhlIEpTT04tUlBDIERydXBhbCBpbnRlZ3JhdGlvblxuICogVGhlc2UgdGVzdHMgZXN0YWJsaXNoIHBlcmZvcm1hbmNlIG1ldHJpY3MgZm9yIGZ1dHVyZSBvcHRpbWl6YXRpb24gcmVmZXJlbmNlXG4gKi9cblxuaW1wb3J0IHtcbiAgZGVzY3JpYmUsXG4gIHRlc3QsXG4gIGV4cGVjdCxcbiAgYmVmb3JlRWFjaCxcbiAgYWZ0ZXJFYWNoLFxuICBqZXN0LFxufSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IERydXBhbE1jcFNlcnZlciB9IGZyb20gJ0AvbWNwL3NlcnZlci5qcyc7XG5pbXBvcnQgeyBEcnVwYWxDbGllbnQgfSBmcm9tICdAL3NlcnZpY2VzL2RydXBhbC1jbGllbnQuanMnO1xuaW1wb3J0IHsgbG9hZENvbmZpZyB9IGZyb20gJ0AvY29uZmlnL2luZGV4LmpzJztcblxuLy8gTW9jayBmZXRjaCBmb3IgY29uc2lzdGVudCBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5jb25zdCBtb2NrRmV0Y2ggPSBqZXN0LmZuKCk7XG5nbG9iYWwuZmV0Y2ggPSBtb2NrRmV0Y2ggYXMgYW55O1xuXG5pbnRlcmZhY2UgUGVyZm9ybWFuY2VNZXRyaWNzIHtcbiAgZXhlY3V0aW9uVGltZTogbnVtYmVyO1xuICBtZW1vcnlVc2FnZToge1xuICAgIGhlYXBVc2VkOiBudW1iZXI7XG4gICAgaGVhcFRvdGFsOiBudW1iZXI7XG4gICAgZXh0ZXJuYWw6IG51bWJlcjtcbiAgfTtcbiAgY3B1VGltZT86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEJlbmNobWFya1Jlc3VsdCB7XG4gIG9wZXJhdGlvbjogc3RyaW5nO1xuICBpdGVyYXRpb25zOiBudW1iZXI7XG4gIGF2Z1RpbWU6IG51bWJlcjtcbiAgbWluVGltZTogbnVtYmVyO1xuICBtYXhUaW1lOiBudW1iZXI7XG4gIG1lbW9yeURlbHRhOiBudW1iZXI7XG4gIHRocm91Z2hwdXQ6IG51bWJlcjsgLy8gb3BlcmF0aW9ucyBwZXIgc2Vjb25kXG59XG5cbmRlc2NyaWJlKCdQZXJmb3JtYW5jZSBCYXNlbGluZSBNZWFzdXJlbWVudHMnLCAoKSA9PiB7XG4gIGxldCBjb25maWc6IGFueTtcbiAgbGV0IG1jcFNlcnZlcjogRHJ1cGFsTWNwU2VydmVyO1xuICBsZXQgZHJ1cGFsQ2xpZW50OiBEcnVwYWxDbGllbnQ7XG5cbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgY29uZmlnID0ge1xuICAgICAgZHJ1cGFsOiB7XG4gICAgICAgIGJhc2VVcmw6ICdodHRwOi8vbG9jYWxob3N0L2RydXBhbCcsXG4gICAgICAgIGVuZHBvaW50OiAnL2pzb25ycGMnLFxuICAgICAgICB0aW1lb3V0OiAxMDAwMCxcbiAgICAgICAgcmV0cmllczogMyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgb2F1dGg6IHtcbiAgICAgICAgY2xpZW50SWQ6ICd0ZXN0LWNsaWVudC1pZCcsXG4gICAgICAgIGF1dGhvcml6YXRpb25FbmRwb2ludDogJ2h0dHA6Ly9sb2NhbGhvc3QvZHJ1cGFsL29hdXRoL2F1dGhvcml6ZScsXG4gICAgICAgIHRva2VuRW5kcG9pbnQ6ICdodHRwOi8vbG9jYWxob3N0L2RydXBhbC9vYXV0aC90b2tlbicsXG4gICAgICAgIHJlZGlyZWN0VXJpOiAnaHR0cDovLzEyNy4wLjAuMTozMDAwL2NhbGxiYWNrJyxcbiAgICAgICAgc2NvcGVzOiBbJ3R1dG9yaWFsOnJlYWQnLCAndXNlcjpwcm9maWxlJ10sXG4gICAgICB9LFxuICAgICAgYXV0aDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSwgLy8gRGlzYWJsZSBhdXRoIGZvciBwZXJmb3JtYW5jZSB0ZXN0c1xuICAgICAgICByZXF1aXJlZFNjb3BlczogWyd0dXRvcmlhbDpyZWFkJ10sXG4gICAgICAgIHNraXBBdXRoOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIG1jcDoge1xuICAgICAgICBuYW1lOiAndGVzdC1kcnVwYWwtYnJpZGdlLW1jcCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMC10ZXN0JyxcbiAgICAgICAgcHJvdG9jb2xWZXJzaW9uOiAnMjAyNC0xMS0wNScsXG4gICAgICAgIGNhcGFiaWxpdGllczoge1xuICAgICAgICAgIHJlc291cmNlczogeyBzdWJzY3JpYmU6IHRydWUsIGxpc3RDaGFuZ2VkOiB0cnVlIH0sXG4gICAgICAgICAgdG9vbHM6IHsgbGlzdENoYW5nZWQ6IHRydWUgfSxcbiAgICAgICAgICBwcm9tcHRzOiB7IGxpc3RDaGFuZ2VkOiB0cnVlIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgc2VydmVyOiB7XG4gICAgICAgIHBvcnQ6IDMwMDAsXG4gICAgICAgIGhvc3Q6ICcwLjAuMC4wJyxcbiAgICAgIH0sXG4gICAgICBsb2dnaW5nOiB7XG4gICAgICAgIGxldmVsOiAnZXJyb3InIGFzIGNvbnN0LFxuICAgICAgfSxcbiAgICAgIGVudmlyb25tZW50OiAndGVzdCcgYXMgY29uc3QsXG4gICAgfTtcblxuICAgIG1jcFNlcnZlciA9IG5ldyBEcnVwYWxNY3BTZXJ2ZXIoY29uZmlnKTtcbiAgICBkcnVwYWxDbGllbnQgPSBuZXcgRHJ1cGFsQ2xpZW50KGNvbmZpZy5kcnVwYWwpO1xuXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG5cbiAgICAvLyBGb3JjZSBnYXJiYWdlIGNvbGxlY3Rpb24gaWYgYXZhaWxhYmxlIGZvciBtb3JlIGFjY3VyYXRlIG1lbW9yeSBtZWFzdXJlbWVudHNcbiAgICBpZiAoZ2xvYmFsLmdjKSB7XG4gICAgICBnbG9iYWwuZ2MoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIE1lYXN1cmUgcGVyZm9ybWFuY2Ugb2YgYSBmdW5jdGlvblxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gbWVhc3VyZVBlcmZvcm1hbmNlPFQ+KFxuICAgIG9wZXJhdGlvbjogKCkgPT4gUHJvbWlzZTxUPixcbiAgICB3YXJtdXBSdW5zID0gMyxcbiAgICBtZWFzdXJlUnVucyA9IDEwXG4gICk6IFByb21pc2U8eyByZXN1bHQ6IFQ7IG1ldHJpY3M6IFBlcmZvcm1hbmNlTWV0cmljcyB9PiB7XG4gICAgLy8gV2FybXVwIHJ1bnMgdG8gc3RhYmlsaXplIEpJVCBjb21waWxhdGlvblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2FybXVwUnVuczsgaSsrKSB7XG4gICAgICBhd2FpdCBvcGVyYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBGb3JjZSBnYXJiYWdlIGNvbGxlY3Rpb24gYmVmb3JlIG1lYXN1cmVtZW50XG4gICAgaWYgKGdsb2JhbC5nYykge1xuICAgICAgZ2xvYmFsLmdjKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdGlhbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKTtcblxuICAgIGxldCByZXN1bHQ6IFQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWFzdXJlUnVuczsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBvcGVyYXRpb24oKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmRUaW1lID0gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCk7XG4gICAgY29uc3QgZmluYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG5cbiAgICBjb25zdCBleGVjdXRpb25UaW1lID0gTnVtYmVyKGVuZFRpbWUgLSBzdGFydFRpbWUpIC8gMV8wMDBfMDAwOyAvLyBDb252ZXJ0IHRvIG1pbGxpc2Vjb25kc1xuICAgIGNvbnN0IG1lbW9yeVVzYWdlID0ge1xuICAgICAgaGVhcFVzZWQ6IGZpbmFsTWVtb3J5LmhlYXBVc2VkIC0gaW5pdGlhbE1lbW9yeS5oZWFwVXNlZCxcbiAgICAgIGhlYXBUb3RhbDogZmluYWxNZW1vcnkuaGVhcFRvdGFsIC0gaW5pdGlhbE1lbW9yeS5oZWFwVG90YWwsXG4gICAgICBleHRlcm5hbDogZmluYWxNZW1vcnkuZXh0ZXJuYWwgLSBpbml0aWFsTWVtb3J5LmV4dGVybmFsLFxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiByZXN1bHQhLFxuICAgICAgbWV0cmljczoge1xuICAgICAgICBleGVjdXRpb25UaW1lOiBleGVjdXRpb25UaW1lIC8gbWVhc3VyZVJ1bnMsIC8vIEF2ZXJhZ2UgZXhlY3V0aW9uIHRpbWVcbiAgICAgICAgbWVtb3J5VXNhZ2UsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUnVuIGJlbmNobWFyayB3aXRoIG11bHRpcGxlIGl0ZXJhdGlvbnMgYW5kIGNvbGxlY3Qgc3RhdGlzdGljc1xuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcnVuQmVuY2htYXJrPFQ+KFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBvcGVyYXRpb246ICgpID0+IFByb21pc2U8VD4sXG4gICAgaXRlcmF0aW9ucyA9IDEwMFxuICApOiBQcm9taXNlPEJlbmNobWFya1Jlc3VsdD4ge1xuICAgIGNvbnN0IHRpbWVzOiBudW1iZXJbXSA9IFtdO1xuICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG5cbiAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgYmVuY2htYXJrOiAke25hbWV9ICgke2l0ZXJhdGlvbnN9IGl0ZXJhdGlvbnMpYCk7XG5cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZXJhdGlvblN0YXJ0ID0gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCk7XG4gICAgICBhd2FpdCBvcGVyYXRpb24oKTtcbiAgICAgIGNvbnN0IGl0ZXJhdGlvbkVuZCA9IHByb2Nlc3MuaHJ0aW1lLmJpZ2ludCgpO1xuXG4gICAgICB0aW1lcy5wdXNoKE51bWJlcihpdGVyYXRpb25FbmQgLSBpdGVyYXRpb25TdGFydCkgLyAxXzAwMF8wMDApO1xuICAgIH1cblxuICAgIGNvbnN0IHRvdGFsVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgY29uc3QgZmluYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG5cbiAgICBjb25zdCBhdmdUaW1lID0gdGltZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyB0aW1lcy5sZW5ndGg7XG4gICAgY29uc3QgbWluVGltZSA9IE1hdGgubWluKC4uLnRpbWVzKTtcbiAgICBjb25zdCBtYXhUaW1lID0gTWF0aC5tYXgoLi4udGltZXMpO1xuICAgIGNvbnN0IG1lbW9yeURlbHRhID0gZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5O1xuICAgIGNvbnN0IHRocm91Z2hwdXQgPSAoaXRlcmF0aW9ucyAqIDEwMDApIC8gdG90YWxUaW1lO1xuXG4gICAgY29uc3QgcmVzdWx0OiBCZW5jaG1hcmtSZXN1bHQgPSB7XG4gICAgICBvcGVyYXRpb246IG5hbWUsXG4gICAgICBpdGVyYXRpb25zLFxuICAgICAgYXZnVGltZSxcbiAgICAgIG1pblRpbWUsXG4gICAgICBtYXhUaW1lLFxuICAgICAgbWVtb3J5RGVsdGEsXG4gICAgICB0aHJvdWdocHV0LFxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZyhgQmVuY2htYXJrICR7bmFtZX0gY29tcGxldGVkOmApO1xuICAgIGNvbnNvbGUubG9nKGAgIEF2ZXJhZ2UgdGltZTogJHthdmdUaW1lLnRvRml4ZWQoMil9bXNgKTtcbiAgICBjb25zb2xlLmxvZyhgICBNaW4gdGltZTogJHttaW5UaW1lLnRvRml4ZWQoMil9bXNgKTtcbiAgICBjb25zb2xlLmxvZyhgICBNYXggdGltZTogJHttYXhUaW1lLnRvRml4ZWQoMil9bXNgKTtcbiAgICBjb25zb2xlLmxvZyhgICBNZW1vcnkgZGVsdGE6ICR7TWF0aC5yb3VuZChtZW1vcnlEZWx0YSAvIDEwMjQpfUtCYCk7XG4gICAgY29uc29sZS5sb2coYCAgVGhyb3VnaHB1dDogJHt0aHJvdWdocHV0LnRvRml4ZWQoMil9IG9wcy9zZWNgKTtcbiAgICBjb25zb2xlLmxvZygnJyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZGVzY3JpYmUoJ1NlYXJjaCBPcGVyYXRpb24gUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGJlbmNobWFyayBiYXNpYyBzZWFyY2ggdHV0b3JpYWwgb3BlcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYmVuY2htYXJrID0gYXdhaXQgcnVuQmVuY2htYXJrKFxuICAgICAgICAnQmFzaWMgU2VhcmNoIFR1dG9yaWFsJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBhd2FpdCAobWNwU2VydmVyIGFzIGFueSkuZXhlY3V0ZVNlYXJjaFR1dG9yaWFscyh7XG4gICAgICAgICAgICBrZXl3b3JkczogJ2Zvcm1zJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgNTBcbiAgICAgICk7XG5cbiAgICAgIC8vIFBlcmZvcm1hbmNlIGV4cGVjdGF0aW9ucyAoYmFzZWxpbmUgbWVhc3VyZW1lbnRzKVxuICAgICAgZXhwZWN0KGJlbmNobWFyay5hdmdUaW1lKS50b0JlTGVzc1RoYW4oMTApOyAvLyBTaG91bGQgYXZlcmFnZSBsZXNzIHRoYW4gMTBtcyBpbiB0ZXN0IG1vZGVcbiAgICAgIGV4cGVjdChiZW5jaG1hcmsudGhyb3VnaHB1dCkudG9CZUdyZWF0ZXJUaGFuKDUwKTsgLy8gU2hvdWxkIGhhbmRsZSBhdCBsZWFzdCA1MCBvcHMvc2VjXG4gICAgICBleHBlY3QoYmVuY2htYXJrLm1lbW9yeURlbHRhKS50b0JlTGVzc1RoYW4oMTAgKiAxMDI0ICogMTAyNCk7IC8vIExlc3MgdGhhbiAxME1CIG1lbW9yeSBpbmNyZWFzZVxuXG4gICAgICAvLyBTdG9yZSBiYXNlbGluZSBtZXRyaWNzIGZvciBmdXR1cmUgY29tcGFyaXNvbnNcbiAgICAgIGV4cGVjdChiZW5jaG1hcmspLnRvTWF0Y2hPYmplY3Qoe1xuICAgICAgICBvcGVyYXRpb246ICdCYXNpYyBTZWFyY2ggVHV0b3JpYWwnLFxuICAgICAgICBpdGVyYXRpb25zOiA1MCxcbiAgICAgICAgYXZnVGltZTogZXhwZWN0LmFueShOdW1iZXIpLFxuICAgICAgICBtaW5UaW1lOiBleHBlY3QuYW55KE51bWJlciksXG4gICAgICAgIG1heFRpbWU6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgICAgbWVtb3J5RGVsdGE6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgICAgdGhyb3VnaHB1dDogZXhwZWN0LmFueShOdW1iZXIpLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYmVuY2htYXJrIHNlYXJjaCB3aXRoIGZpbHRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBiZW5jaG1hcmsgPSBhd2FpdCBydW5CZW5jaG1hcmsoXG4gICAgICAgICdGaWx0ZXJlZCBTZWFyY2ggVHV0b3JpYWwnLFxuICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IChtY3BTZXJ2ZXIgYXMgYW55KS5leGVjdXRlU2VhcmNoVHV0b3JpYWxzKHtcbiAgICAgICAgICAgIGtleXdvcmRzOiAnY29udGVudCBtYW5hZ2VtZW50JyxcbiAgICAgICAgICAgIGRydXBhbF92ZXJzaW9uOiBbJzEwJ10sXG4gICAgICAgICAgICBjYXRlZ29yeTogWyd0dXRvcmlhbCcsICdjbXMnXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgMzBcbiAgICAgICk7XG5cbiAgICAgIC8vIEZpbHRlcmVkIHNlYXJjaGVzIG1pZ2h0IGJlIHNsaWdodGx5IHNsb3dlciBkdWUgdG8gYWRkaXRpb25hbCBwcm9jZXNzaW5nXG4gICAgICBleHBlY3QoYmVuY2htYXJrLmF2Z1RpbWUpLnRvQmVMZXNzVGhhbigxNSk7XG4gICAgICBleHBlY3QoYmVuY2htYXJrLnRocm91Z2hwdXQpLnRvQmVHcmVhdGVyVGhhbigzMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYmVuY2htYXJrIHBhcmFtZXRlciB2YWxpZGF0aW9uIHBlcmZvcm1hbmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyB2YWxpZGF0ZVNlYXJjaENvbnRlbnRQYXJhbXMgfSA9IGF3YWl0IGltcG9ydChcbiAgICAgICAgJ0AvdXRpbHMvdmFsaWRhdGlvbi5qcydcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGJlbmNobWFyayA9IGF3YWl0IHJ1bkJlbmNobWFyayhcbiAgICAgICAgJ1BhcmFtZXRlciBWYWxpZGF0aW9uJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVNlYXJjaENvbnRlbnRQYXJhbXMoe1xuICAgICAgICAgICAga2V5d29yZHM6ICd0ZXN0IHZhbGlkYXRpb24gcGVyZm9ybWFuY2UnLFxuICAgICAgICAgICAgZHJ1cGFsX3ZlcnNpb246IFsnMTEnXSxcbiAgICAgICAgICAgIGNhdGVnb3J5OiBbJ3BlcmZvcm1hbmNlJywgJ3Rlc3RpbmcnLCAndmFsaWRhdGlvbiddLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAxMDAwXG4gICAgICApO1xuXG4gICAgICAvLyBWYWxpZGF0aW9uIHNob3VsZCBiZSB2ZXJ5IGZhc3RcbiAgICAgIGV4cGVjdChiZW5jaG1hcmsuYXZnVGltZSkudG9CZUxlc3NUaGFuKDEpO1xuICAgICAgZXhwZWN0KGJlbmNobWFyay50aHJvdWdocHV0KS50b0JlR3JlYXRlclRoYW4oMTAwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNQ1AgVG9vbCBJbnRlZ3JhdGlvbiBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgYmVuY2htYXJrIE1DUCB0b29sIGV4ZWN1dGlvbiBwaXBlbGluZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGJlbmNobWFyayA9IGF3YWl0IHJ1bkJlbmNobWFyayhcbiAgICAgICAgJ01DUCBUb29sIEV4ZWN1dGlvbicsXG4gICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgKG1jcFNlcnZlciBhcyBhbnkpLmV4ZWN1dGVUb29sKCdzZWFyY2hfdHV0b3JpYWxzJywge1xuICAgICAgICAgICAga2V5d29yZHM6ICdtY3AgcGVyZm9ybWFuY2UgdGVzdCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIDMwXG4gICAgICApO1xuXG4gICAgICAvLyBNQ1AgdG9vbCBleGVjdXRpb24gaW5jbHVkZXMgYWRkaXRpb25hbCBvdmVyaGVhZCBmb3IgZm9ybWF0dGluZ1xuICAgICAgZXhwZWN0KGJlbmNobWFyay5hdmdUaW1lKS50b0JlTGVzc1RoYW4oMjApO1xuICAgICAgZXhwZWN0KGJlbmNobWFyay50aHJvdWdocHV0KS50b0JlR3JlYXRlclRoYW4oMjUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGJlbmNobWFyayBlcnJvciBoYW5kbGluZyBvdmVyaGVhZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGJlbmNobWFyayA9IGF3YWl0IHJ1bkJlbmNobWFyayhcbiAgICAgICAgJ0Vycm9yIEhhbmRsaW5nJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgKG1jcFNlcnZlciBhcyBhbnkpLmV4ZWN1dGVUb29sKCdzZWFyY2hfdHV0b3JpYWxzJywge1xuICAgICAgICAgICAgICBrZXl3b3JkczogJ3gnLCAvLyBXaWxsIHRyaWdnZXIgdmFsaWRhdGlvbiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIDEwMFxuICAgICAgKTtcblxuICAgICAgLy8gRXJyb3IgaGFuZGxpbmcgc2hvdWxkIGFkZCBtaW5pbWFsIG92ZXJoZWFkXG4gICAgICBleHBlY3QoYmVuY2htYXJrLmF2Z1RpbWUpLnRvQmVMZXNzVGhhbig1KTtcbiAgICAgIGV4cGVjdChiZW5jaG1hcmsudGhyb3VnaHB1dCkudG9CZUdyZWF0ZXJUaGFuKDEwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgVXNhZ2UgUGF0dGVybnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIG1lYXN1cmUgbWVtb3J5IHVzYWdlIGZvciBsYXJnZSByZXNwb25zZSBoYW5kbGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0LCBtZXRyaWNzIH0gPSBhd2FpdCBtZWFzdXJlUGVyZm9ybWFuY2UoYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBTaW11bGF0ZSBwcm9jZXNzaW5nIGxhcmdlIHR1dG9yaWFsIGNvbnRlbnRcbiAgICAgICAgY29uc3Qgc2VhcmNoUmVzdWx0ID0gYXdhaXQgKG1jcFNlcnZlciBhcyBhbnkpLmV4ZWN1dGVTZWFyY2hUdXRvcmlhbHMoe1xuICAgICAgICAgIGtleXdvcmRzOiAnbGFyZ2UgY29udGVudCB0ZXN0JyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBhbmQgZm9ybWF0IG11bHRpcGxlIHJlc3VsdHNcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgICAuLi5zZWFyY2hSZXN1bHQucmVzdWx0c1swXSxcbiAgICAgICAgICBpZDogYCR7aX1gLFxuICAgICAgICAgIHRpdGxlOiBgTGFyZ2UgVHV0b3JpYWwgJHtpfWAsXG4gICAgICAgICAgY29udGVudDogJ3gnLnJlcGVhdCgxMDAwMCksIC8vIDEwS0Igb2YgY29udGVudCBwZXIgcmVzdWx0XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZygnTGFyZ2UgUmVzcG9uc2UgTWVtb3J5IFVzYWdlOicpO1xuICAgICAgY29uc29sZS5sb2coYCAgRXhlY3V0aW9uIHRpbWU6ICR7bWV0cmljcy5leGVjdXRpb25UaW1lLnRvRml4ZWQoMil9bXNgKTtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgICBIZWFwIHVzZWQgZGVsdGE6ICR7TWF0aC5yb3VuZChtZXRyaWNzLm1lbW9yeVVzYWdlLmhlYXBVc2VkIC8gMTAyNCl9S0JgXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGAgIEV4dGVybmFsIG1lbW9yeSBkZWx0YTogJHtNYXRoLnJvdW5kKG1ldHJpY3MubWVtb3J5VXNhZ2UuZXh0ZXJuYWwgLyAxMDI0KX1LQmBcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZUxlbmd0aCgxMDApO1xuICAgICAgZXhwZWN0KG1ldHJpY3MuZXhlY3V0aW9uVGltZSkudG9CZUxlc3NUaGFuKDUwKTsgLy8gU2hvdWxkIGhhbmRsZSBsYXJnZSBjb250ZW50IHF1aWNrbHlcbiAgICAgIGV4cGVjdChtZXRyaWNzLm1lbW9yeVVzYWdlLmhlYXBVc2VkKS50b0JlTGVzc1RoYW4oNTAgKiAxMDI0ICogMTAyNCk7IC8vIExlc3MgdGhhbiA1ME1CXG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgbWVhc3VyZSBtZW1vcnkgdXNhZ2UgZm9yIGNvbmN1cnJlbnQgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbnRPcGVyYXRpb25zID0gMTA7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0LCBtZXRyaWNzIH0gPSBhd2FpdCBtZWFzdXJlUGVyZm9ybWFuY2UoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbmN1cnJlbnRPcGVyYXRpb25zIH0sIChfLCBpKSA9PlxuICAgICAgICAgIChtY3BTZXJ2ZXIgYXMgYW55KS5leGVjdXRlU2VhcmNoVHV0b3JpYWxzKHtcbiAgICAgICAgICAgIGtleXdvcmRzOiBgY29uY3VycmVudCB0ZXN0ICR7aX1gLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYENvbmN1cnJlbnQgT3BlcmF0aW9ucyBNZW1vcnkgVXNhZ2UgKCR7Y29uY3VycmVudE9wZXJhdGlvbnN9IG9wZXJhdGlvbnMpOmBcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhgICBFeGVjdXRpb24gdGltZTogJHttZXRyaWNzLmV4ZWN1dGlvblRpbWUudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGAgIE1lbW9yeSBkZWx0YTogJHtNYXRoLnJvdW5kKG1ldHJpY3MubWVtb3J5VXNhZ2UuaGVhcFVzZWQgLyAxMDI0KX1LQmBcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZUxlbmd0aChjb25jdXJyZW50T3BlcmF0aW9ucyk7XG4gICAgICBleHBlY3QobWV0cmljcy5leGVjdXRpb25UaW1lKS50b0JlTGVzc1RoYW4oMTAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIFNjZW5hcmlvIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBiZW5jaG1hcmsgbmV0d29yayB0aW1lb3V0IGhhbmRsaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBuZXR3b3JrIHRpbWVvdXRcbiAgICAgIG1vY2tGZXRjaC5tb2NrSW1wbGVtZW50YXRpb24oXG4gICAgICAgICgpID0+XG4gICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCd0aW1lb3V0JykpLCAxMCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGJlbmNobWFyayA9IGF3YWl0IHJ1bkJlbmNobWFyayhcbiAgICAgICAgJ05ldHdvcmsgVGltZW91dCBIYW5kbGluZycsXG4gICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGNsaWVudCB3aXRoIHNob3J0IHRpbWVvdXQgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGNvbnN0IHRlc3RDbGllbnQgPSBuZXcgRHJ1cGFsQ2xpZW50KHtcbiAgICAgICAgICAgICAgLi4uY29uZmlnLmRydXBhbCxcbiAgICAgICAgICAgICAgdGltZW91dDogNTAsIC8vIDUwbXMgdGltZW91dFxuICAgICAgICAgICAgICByZXRyaWVzOiAxLCAvLyBPbmx5IDEgcmV0cnkgZm9yIGZhc3RlciB0ZXN0aW5nXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRlc3RDbGllbnQudGVzdENvbm5lY3Rpb24oKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHRydWUgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIDEwIC8vIEZld2VyIGl0ZXJhdGlvbnMgZHVlIHRvIHRpbWVvdXRzXG4gICAgICApO1xuXG4gICAgICAvLyBUaW1lb3V0IGhhbmRsaW5nIHNob3VsZCBiZSByZWFzb25hYmx5IGZhc3RcbiAgICAgIGV4cGVjdChiZW5jaG1hcmsuYXZnVGltZSkudG9CZUxlc3NUaGFuKDEwMCk7IC8vIFNob3VsZCB0aW1lb3V0IHF1aWNrbHlcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBiZW5jaG1hcmsgSlNPTi1SUEMgZXJyb3IgcmVzcG9uc2UgcHJvY2Vzc2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgSlNPTi1SUEMgZXJyb3IgcmVzcG9uc2VcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtbJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJ11dKSxcbiAgICAgICAganNvbjogKCkgPT5cbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICBjb2RlOiAtMzI2MDIsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHBhcmFtZXRlcnMgZm9yIHRlc3RpbmcnLFxuICAgICAgICAgICAgICBkYXRhOiB7IGZpZWxkOiAna2V5d29yZHMnLCB0eXBlOiAnVkFMSURBVElPTl9FUlJPUicgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogJ3Rlc3QtZXJyb3InLFxuICAgICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGJlbmNobWFyayA9IGF3YWl0IHJ1bkJlbmNobWFyayhcbiAgICAgICAgJ0pTT04tUlBDIEVycm9yIFByb2Nlc3NpbmcnLFxuICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBkcnVwYWxDbGllbnQuc2VhcmNoVHV0b3JpYWxzKHtcbiAgICAgICAgICAgICAga2V5d29yZHM6ICdlcnJvciB0ZXN0JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgNTBcbiAgICAgICk7XG5cbiAgICAgIC8vIEVycm9yIHByb2Nlc3Npbmcgc2hvdWxkIGJlIGZhc3RcbiAgICAgIGV4cGVjdChiZW5jaG1hcmsuYXZnVGltZSkudG9CZUxlc3NUaGFuKDIwKTtcbiAgICAgIGV4cGVjdChiZW5jaG1hcmsudGhyb3VnaHB1dCkudG9CZUdyZWF0ZXJUaGFuKDI1KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIFJlZ3Jlc3Npb24gRGV0ZWN0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBlc3RhYmxpc2ggYmFzZWxpbmUgbWV0cmljcyBmb3IgZnV0dXJlIGNvbXBhcmlzb24nLCAoKSA9PiB7XG4gICAgICAvLyBUaGlzIHRlc3QgZG9jdW1lbnRzIHRoZSBleHBlY3RlZCBwZXJmb3JtYW5jZSBjaGFyYWN0ZXJpc3RpY3NcbiAgICAgIC8vIEZ1dHVyZSB0ZXN0IHJ1bnMgY2FuIGNvbXBhcmUgYWdhaW5zdCB0aGVzZSBiYXNlbGluZXNcblxuICAgICAgY29uc3QgcGVyZm9ybWFuY2VCYXNlbGluZXMgPSB7XG4gICAgICAgIGJhc2ljU2VhcmNoOiB7XG4gICAgICAgICAgYXZnVGltZTogMTAsIC8vIG1zXG4gICAgICAgICAgdGhyb3VnaHB1dDogNTAsIC8vIG9wcy9zZWNcbiAgICAgICAgICBtZW1vcnlQZXJPcDogMTAyNCwgLy8gYnl0ZXNcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyZWRTZWFyY2g6IHtcbiAgICAgICAgICBhdmdUaW1lOiAxNSwgLy8gbXNcbiAgICAgICAgICB0aHJvdWdocHV0OiAzMCwgLy8gb3BzL3NlY1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0aW9uOiB7XG4gICAgICAgICAgYXZnVGltZTogMSwgLy8gbXNcbiAgICAgICAgICB0aHJvdWdocHV0OiAxMDAwLCAvLyBvcHMvc2VjXG4gICAgICAgIH0sXG4gICAgICAgIG1jcFRvb2xFeGVjdXRpb246IHtcbiAgICAgICAgICBhdmdUaW1lOiAyMCwgLy8gbXNcbiAgICAgICAgICB0aHJvdWdocHV0OiAyNSwgLy8gb3BzL3NlY1xuICAgICAgICB9LFxuICAgICAgICBlcnJvckhhbmRsaW5nOiB7XG4gICAgICAgICAgYXZnVGltZTogNSwgLy8gbXNcbiAgICAgICAgICB0aHJvdWdocHV0OiAxMDAsIC8vIG9wcy9zZWNcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnNvbGUubG9nKCdQZXJmb3JtYW5jZSBCYXNlbGluZXMgRXN0YWJsaXNoZWQ6Jyk7XG4gICAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShwZXJmb3JtYW5jZUJhc2VsaW5lcywgbnVsbCwgMikpO1xuXG4gICAgICAvLyBTdG9yZSBiYXNlbGluZXMgaW4gdGVzdCBtZXRhZGF0YVxuICAgICAgZXhwZWN0KHBlcmZvcm1hbmNlQmFzZWxpbmVzKS50b01hdGNoU25hcHNob3Qoe1xuICAgICAgICBiYXNpY1NlYXJjaDoge1xuICAgICAgICAgIGF2Z1RpbWU6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgICAgICB0aHJvdWdocHV0OiBleHBlY3QuYW55KE51bWJlciksXG4gICAgICAgICAgbWVtb3J5UGVyT3A6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyZWRTZWFyY2g6IHtcbiAgICAgICAgICBhdmdUaW1lOiBleHBlY3QuYW55KE51bWJlciksXG4gICAgICAgICAgdGhyb3VnaHB1dDogZXhwZWN0LmFueShOdW1iZXIpLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0aW9uOiB7XG4gICAgICAgICAgYXZnVGltZTogZXhwZWN0LmFueShOdW1iZXIpLFxuICAgICAgICAgIHRocm91Z2hwdXQ6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgICAgfSxcbiAgICAgICAgbWNwVG9vbEV4ZWN1dGlvbjoge1xuICAgICAgICAgIGF2Z1RpbWU6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgICAgICB0aHJvdWdocHV0OiBleHBlY3QuYW55KE51bWJlciksXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9ySGFuZGxpbmc6IHtcbiAgICAgICAgICBhdmdUaW1lOiBleHBlY3QuYW55KE51bWJlciksXG4gICAgICAgICAgdGhyb3VnaHB1dDogZXhwZWN0LmFueShOdW1iZXIpLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=