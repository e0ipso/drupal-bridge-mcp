{"file":"/workspace/src/auth/token-manager.ts","mappings":"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","names":[],"sources":["/workspace/src/auth/token-manager.ts"],"sourcesContent":["/**\n * Simplified token management system for MVP - file-based storage without encryption\n */\n\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { homedir } from 'os';\nimport jwt from 'jsonwebtoken';\nimport { createHash } from 'crypto';\nimport type { OAuthTokens, OAuthClient } from './oauth-client.js';\n\nexport interface StoredTokens extends OAuthTokens {\n  expiresAt?: number;\n  userId: string;\n  scopes: string[];\n  refreshExpiresAt?: number;\n}\n\nexport interface TokenValidationResult {\n  isValid: boolean;\n  isExpired: boolean;\n  needsRefresh: boolean;\n  scopes?: string[];\n  userId?: string;\n}\n\n/**\n * Simplified token manager for MVP - file-based storage without encryption\n */\nexport class TokenManager {\n  private readonly tokenDir: string;\n  private readonly tokenFile: string;\n  private readonly userId: string;\n  private readonly oauthClient: OAuthClient;\n\n  constructor(oauthClient: OAuthClient, userId?: string) {\n    this.oauthClient = oauthClient;\n    this.tokenDir = join(homedir(), '.drupal-bridge-mcp');\n\n    // Create user fingerprint for file naming\n    this.userId = userId || this.createUserFingerprint();\n    const userHash = this.hash(this.userId).substring(0, 8);\n    this.tokenFile = join(this.tokenDir, `tokens_${userHash}.json`);\n  }\n\n  /**\n   * Store tokens in simple file format (MVP - no encryption)\n   */\n  async storeTokens(\n    tokens: OAuthTokens,\n    userId: string,\n    scopes: string[] = []\n  ): Promise<void> {\n    try {\n      await this.ensureTokenDirectory();\n\n      const storedTokens: StoredTokens = {\n        ...tokens,\n        userId,\n        scopes,\n        expiresAt: tokens.expiresIn\n          ? Date.now() + tokens.expiresIn * 1000\n          : undefined,\n        // Assume refresh token expires in 30 days if not specified\n        refreshExpiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000,\n      };\n\n      // TODO: Add encryption for production deployment\n      await fs.writeFile(\n        this.tokenFile,\n        JSON.stringify(storedTokens, null, 2),\n        { mode: 0o600 }\n      ); // Owner read/write only\n    } catch (error) {\n      throw new Error(\n        `Failed to store tokens: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Retrieve stored tokens from simple file format\n   */\n  async getTokens(userId?: string): Promise<StoredTokens | null> {\n    try {\n      const fileContent = await fs.readFile(this.tokenFile, 'utf8');\n      const tokens: StoredTokens = JSON.parse(fileContent);\n\n      // Validate user ID if provided\n      if (userId && tokens.userId !== userId) {\n        return null;\n      }\n\n      return tokens;\n    } catch (error) {\n      // Check for file not found error (ENOENT)\n      if (\n        error &&\n        typeof error === 'object' &&\n        'code' in error &&\n        error.code === 'ENOENT'\n      ) {\n        return null; // File doesn't exist\n      }\n\n      // Handle JSON parsing errors - treat as if file doesn't exist\n      if (error instanceof SyntaxError) {\n        return null;\n      }\n\n      throw new Error(\n        `Failed to retrieve tokens: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Get valid access token, refreshing if necessary\n   */\n  async getValidAccessToken(\n    userId?: string,\n    requiredScopes?: string[]\n  ): Promise<string | null> {\n    const tokens = await this.getTokens(userId);\n    if (!tokens) {\n      return null;\n    }\n\n    const validation = await this.validateToken(\n      tokens.accessToken,\n      requiredScopes\n    );\n\n    if (validation.isValid && !validation.needsRefresh) {\n      return tokens.accessToken;\n    }\n\n    // Try to refresh if token is expired but we have a refresh token\n    if (validation.needsRefresh && tokens.refreshToken) {\n      try {\n        const refreshedTokens = await this.oauthClient.refreshToken(\n          tokens.refreshToken\n        );\n\n        // Store refreshed tokens\n        await this.storeTokens(refreshedTokens, tokens.userId, tokens.scopes);\n\n        return refreshedTokens.accessToken;\n      } catch {\n        // Refresh failed - tokens are invalid\n        await this.clearTokens();\n        return null;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Validate JWT access token\n   */\n  async validateToken(\n    accessToken: string,\n    requiredScopes?: string[]\n  ): Promise<TokenValidationResult> {\n    try {\n      // Decode JWT without verification to get basic info\n      const decoded = jwt.decode(accessToken) as jwt.JwtPayload | null;\n\n      if (!decoded || typeof decoded !== 'object') {\n        return { isValid: false, isExpired: true, needsRefresh: true };\n      }\n\n      const now = Math.floor(Date.now() / 1000);\n      const exp = decoded.exp || 0;\n      const isExpired = exp <= now;\n\n      // Check if token expires within 5 minutes (refresh buffer)\n      const needsRefresh = exp <= now + 300; // 5 minutes\n\n      // Validate scopes if required\n      let scopesValid = true;\n      if (requiredScopes && requiredScopes.length > 0) {\n        const tokenScopes = decoded.scope ? decoded.scope.split(' ') : [];\n        scopesValid = requiredScopes.every(scope =>\n          tokenScopes.includes(scope)\n        );\n      }\n\n      return {\n        isValid: !isExpired && scopesValid,\n        isExpired,\n        needsRefresh,\n        scopes:\n          typeof decoded.scope === 'string' ? decoded.scope.split(' ') : [],\n        userId: decoded.sub as string,\n      };\n    } catch {\n      return { isValid: false, isExpired: true, needsRefresh: true };\n    }\n  }\n\n  /**\n   * Validate token signature against Drupal's public key\n   */\n  async validateTokenSignature(\n    accessToken: string,\n    publicKey: string\n  ): Promise<boolean> {\n    try {\n      jwt.verify(accessToken, publicKey, {\n        algorithms: ['RS256'],\n        issuer: process.env.DRUPAL_BASE_URL,\n        audience: process.env.OAUTH_CLIENT_ID,\n      });\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Clear stored tokens\n   */\n  async clearTokens(): Promise<void> {\n    try {\n      await fs.unlink(this.tokenFile);\n    } catch (error) {\n      // Ignore if file doesn't exist - check for ENOENT code directly since instanceof Error might fail in Node.js\n      if (\n        error &&\n        typeof error === 'object' &&\n        'code' in error &&\n        (error as NodeJS.ErrnoException).code === 'ENOENT'\n      ) {\n        // File doesn't exist, which is fine for clearing tokens\n        return;\n      }\n\n      // Re-throw any other errors\n      throw error;\n    }\n  }\n\n  /**\n   * Check if user has valid tokens\n   */\n  async hasValidTokens(\n    userId?: string,\n    requiredScopes?: string[]\n  ): Promise<boolean> {\n    const accessToken = await this.getValidAccessToken(userId, requiredScopes);\n    return accessToken !== null;\n  }\n\n  /**\n   * Get token info without revealing the token value\n   */\n  async getTokenInfo(userId?: string): Promise<{\n    hasTokens: boolean;\n    expiresAt?: number;\n    scopes?: string[];\n    userId?: string;\n    isExpired?: boolean;\n    needsRefresh?: boolean;\n  } | null> {\n    const tokens = await this.getTokens(userId);\n    if (!tokens) {\n      return { hasTokens: false };\n    }\n\n    const validation = await this.validateToken(tokens.accessToken);\n\n    return {\n      hasTokens: true,\n      expiresAt: tokens.expiresAt,\n      scopes: tokens.scopes,\n      userId: tokens.userId,\n      isExpired: validation.isExpired,\n      needsRefresh: validation.needsRefresh,\n    };\n  }\n\n  /**\n   * Ensure token directory exists with proper permissions\n   */\n  private async ensureTokenDirectory(): Promise<void> {\n    try {\n      await fs.mkdir(this.tokenDir, { recursive: true, mode: 0o700 }); // Owner access only\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          'code' in error &&\n          (error as NodeJS.ErrnoException).code === 'EEXIST'\n        )\n      ) {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Create secure fingerprint for user identification (simplified from CryptoUtils)\n   */\n  private createUserFingerprint(): string {\n    const hostname = process.env.HOSTNAME || 'unknown';\n    const username = process.env.USER || process.env.USERNAME || 'unknown';\n    const timestamp = Date.now().toString();\n    return this.hash(`${hostname}:${username}:${timestamp}`).substring(0, 16);\n  }\n\n  /**\n   * Hash data using SHA-256 (simplified from CryptoUtils)\n   */\n  private hash(data: string): string {\n    return createHash('sha256').update(data).digest('hex');\n  }\n}\n"],"version":3}